[{"categories":["javascript"],"contents":"這座山終於快爬完一半了\u0026hellip;不得不說如果真的不知道該怎麼做時參考網路上類似的範例是一個還不錯的選擇,不然你可能卡在路上半天還在迷路\u0026hellip;\nPhoto by pixabay\nBOSS 弱點 【特定技術】遊戲規則\n 繪圖區請使用 Canvas 來設計，上方的控制列與下方的畫筆調整可不用 SAVE ：點擊後可直接下載轉出的 PNG 圖片 CLEAR ALL：清除畫版樣式 UNDO、REDO：上一步、下一步 點擊箭頭時，功能列介面皆可進行收闔 【擴充功能】請再自行增加「兩個功能」，我相信勇者們都是很有梗的~  Canvas DOM vs Canvas\nDOM在繪製主要是透過瀏覽器的graphic api來做,因為實際的細節是由瀏覽器處理所以操作上較為簡單,但是DOM的操作是很耗內存的,DOM越多內存的消耗量越大,而canvas雖然操作上較為困難但是速度快且善於處理大量的元素\n要使用時在html內加上canvas,之後js透過id做canvas的相關設定\nHTML\n\u0026lt;canvas id=\u0026#34;canvas-panel\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt;\rJavascript\n// 基礎設定\r function canvas_setting() {\r//獲取2d畫筆物件\r if (this.canvas.getContext) {\rthis.canvas.width = window.innerWidth; //設定canvas寬度為畫面寬度\r this.canvas.height = window.innerHeight; //設定canvas高度為畫面高度\r this.ctx = this.canvas.getContext(\u0026#34;2d\u0026#34;); //獲取canvas 2d畫筆\r this.ctx.lineWidth = this.line_width; //設定線條粗細\r this.ctx.strokeStyle = this.pen_color; //設定線條顏色\r } else {\ralert(\u0026#34;Browser not support canvas\u0026#34;);\r}\r}\r//繪畫設定  function drawImg(x1, y1, x2, y2) {//畫圖時需要畫筆以及兩點的x,y座標\r //設定線條的端點如何繪製,round為端點帶有一個半圓形的線蓋\r if (this.ctx.lineCap !== \u0026#34;round\u0026#34;) {\rthis.ctx.lineCap = \u0026#34;round\u0026#34;;\r}\r// 設定線條與線條之間如何連結,round為圓弧形連接\r if (this.ctx.lineJoin !== \u0026#34;round\u0026#34;) {\rthis.ctx.lineJoin = \u0026#34;round\u0026#34;;\r}\rthis.ctx.beginPath(); //開始繪製  this.ctx.moveTo(x1, y1); //設定開始位置\r this.ctx.lineTo(x2, y2); //設定移動位置\r this.ctx.closePath(); //關閉路徑\r this.ctx.stroke(); //路徑上色\r }\rMouse Event Mouse Event是完成畫板基本繪畫功能的一個非常重要的事件,要完成基本繪畫功能需要下列三個事件監聽\n mousedown - 滑鼠壓下 mousemove - 滑鼠移動 mouseup - 滑鼠放開  this.canvas.addEventListener(\u0026#34;mousedown\u0026#34;, (e) =\u0026gt; {\r//buttons為1表示為按下的滑鼠按鍵為左鍵-不讓其他鍵觸發事件\r if (e.buttons === 1) {\rthis.pos_x = e.clientX; //抓取滑鼠水平位置\r this.pos_y = e.clientY; //抓取滑鼠垂直位置\r this.drawing = true;\r}\r});\rthis.canvas.addEventListener(\u0026#34;mousemove\u0026#34;, (e) =\u0026gt; {\r// 要畫成線需要兩組x、y座標\r this.drawImg(this.pos_x,this.pos_y,e.clientX,e.clientY);\rthis.pos_x = e.clientX;\rthis.pos_y = e.clientY;\r});\r// 滑鼠移開時畫筆位置重置,drawing狀態為false\r this.canvas.addEventListener(\u0026#34;mouseup\u0026#34;, (e) =\u0026gt; {\r// 避免繪畫時有放開其他滑鼠按鍵的狀況\r if (e.buttons !== 1) {\rthis.pos_x = 0; //抓取滑鼠水平位置歸0\r this.pos_y = 0; //抓取滑鼠垂直位置歸0\r this.drawing = false;\r//儲存當前的狀態方便用於上一步、下一步\r this.step += 1; //歷史紀錄步驟+1\r this.record_Arr.push(this.canvas.toDataURL()); //將資料存成base64編碼後放進陣列,之後上一步、下一步會用到\r }\r});\rData URI Data URI在網頁上的作用就是透過將圖片轉換為文字編碼的方式直接儲存在HTML、CSS內來降低Http請求次數(一張圖片就是一個請求)進而增進網頁載入效能的一個方式，但是同時他也有著無法快取、可讀性差、檔案變大(大約33%)以及如果圖檔有變化時需要重新編碼的缺點,所以要使用的話還是要依照當下狀況來看\u0026hellip;,在這一題裡Data URI是用作「下載圖片」以及繪畫時的「上一步、下一步」用\nData URI格式\ndata:[\u0026lt;mediatype\u0026gt;][;base64],\u0026lt;data\u0026gt;\r我們可以透過canvas內建的toDataURL將其轉換成Data URI後下載\ncanvas.toDataURL(type, encoderOptions);\r// type為類型 ex: image/png(默認)、image/jpeg、image/webp...\r // encoderOptions為圖片品質範圍為0~1,指定圖片格式為image/jpeg 或 image/webp\r程式碼\n// 下載圖片\r function downloadImg() {\rconst dataUrl = this.canvas.toDataURL(\u0026#34;image/png\u0026#34;);\rdocument.querySelector(\u0026#34;.save\u0026#34;).href = dataUrl; //轉換完後丟給a標籤,之後只要點擊標籤就會下載\r }\r// 不論是上一步、下一步都需要先等待圖片載入完畢\r // 上一步\r function undo(){\rif (this.step \u0026gt; 0) {\r//先將狀態回到上一步\r var last_history = new Image();\rvar window_width = window.innerWidth;\rvar window_height = window.innerHeight;\rlast_history.src = this.record_Arr[this.step-1]; //載入上一筆歷史紀錄\r last_history.onload = () =\u0026gt; {\rthis.ctx.clearRect(0, 0, window_width, window_height); //繪圖前必須先清除畫布\r this.ctx.drawImage(last_history, 0, 0); //載入圖片\r this.step-=1; //歷史紀錄步驟-1\r };\r}\r}\r// 下一步\r function redo_canvas() {\r// 如果有上一步操作才可以下一步\r if (this.step \u0026lt; this.record_Arr.length) {\rvar last_history = new Image();\rvar window_width = window.innerWidth;\rvar window_height = window.innerHeight;\rlast_history.src = this.record_Arr[this.step + 1]; //載入下一筆歷史紀錄\r last_history.onload = () =\u0026gt; {\rthis.ctx.clearRect(0, 0, window_width, window_height); //繪圖前必須先清除畫布\r this.ctx.drawImage(last_history, 0, 0); //載入圖片\r this.step +=1 ; //歷史紀錄步驟+1\r };\r}\r}\r客製化功能 這次客製化了「顏色選取器」以及「橡皮擦」這兩個功能,我們直接來看程式碼\n顏色選取器\n//選取色盤的顏色並變換畫筆顏色  function color_picker() {\rvar color_picker = document.getElementById(\u0026#34;color-panel\u0026#34;); //抓取type為color的input\r color_picker.addEventListener(\u0026#34;input\u0026#34;, (e)=\u0026gt; {\rthis.selected_color = e.target.value; //抓取選取到的顏色\r document.querySelector(\u0026#39;.colors .show\u0026#39;).parentElement.style.backgroundColor = this.selected_color; //將原先勾選到的顏色改成目前選取的顏色\r this.pen_color = this.selected_color; //改變畫筆顏色\r this.ctx.strokeStyle = this.pen_color; //改變畫筆顏色\r });\r}\r橡皮擦\n橡皮擦原先的想法是想說將畫筆的顏色直接改成跟背景顏色一樣就可以了,但是png檔的背景是透明的,所以輸出的圖片會變成這樣 (灰色的部分為橡皮擦擦過的路徑)\n所以單純改變畫筆顏色是不行的,但是我們可以透過canvas的clearRect來將滑鼠滑過的區域清除掉\nthis.ctx.clearRect(x,y,width,height); //x、y為座標 width、height為清除的寬與高\r這樣橡皮擦的功能就完成了,詳細的狀況可以去看我寫的code\u0026hellip;\n額外補充 canvas需要透過直接寫在HTML或是透過JS去設定寬高且無法透過CSS設定,在這樣的情況下如果要讓canvas的寬高隨螢幕resize時我們直覺會直接註冊一個resize的事件監聽，但是直接更改canvas的寬跟高會導致畫布被清空的bug\u0026hellip;，想要解決這樣的問題我們可以透過undo、redo有用到的歷史紀錄，在螢幕resize時載入最新的一筆歷史紀錄,這樣即便在resize後畫布上的圖依然還會存在\nwindow.addEventListener(\u0026#34;resize\u0026#34;, () =\u0026gt; {\rthis.canvas.width = window.innerWidth;\rthis.canvas.height = window.innerHeight;\r//先將狀態回到上一步\r var last_history = new Image();\rvar window_width = window.innerWidth;\rvar window_height = window.innerHeight;\rlast_history.src = this.record_Arr[this.step];\rlast_history.onload = () =\u0026gt; {\rthis.ctx.clearRect(0, 0, window_width, window_height);\rthis.ctx.drawImage(last_history, 0, 0);\r};\r});\r7F畫板 demo連結  最近對於時間管理真的非常有感觸，有很多應該做以及想做的事情像是刷題目、寫文章、進修程式、運動、看課外書、交女朋友\u0026hellip;，這些全部都要花時間,懂得如何利用零碎的時間並增進做事效率真的很重要，希望有朝一日我也能夠成為一位專業的時間管理大師\u0026hellip;\nPhoto by pixabay\n補充資料 Canvas API MDN\nDOM vs Canvas\nInput Color MDN\nMousedown MDN\nMouse Event 小筆記\n使用 DATA URI 將圖片以 Base64 編碼並內崁至網頁中，加速載入速度\n","permalink":"https://bjmqfg83.github.io/blog/drawing_board/","tags":["程式學習"],"title":"畫板drawing board-六角學院Javascript新手地下城"},{"categories":["javascript"],"contents":"遊戲規則  0~20 秒為 1位數計算 (5-3)，21~40 秒為 2 位數計算 (30*19)，41~60 秒為 3 位數計算 (332+312)，加減乘除規則請用隨機產生，不可寫死題目，60 秒內可無限次數答題。 0~40 秒答對加一分，41~60 秒答對加五分，答錯扣一分，最多僅能扣到零分 【特定技術】不可設計跳轉頁面，都得在同一頁內部切換頁面完成。  使用技術 JS : Vue、if else、Math、switch、localStorage、setInterval\nCSS: SCSS(CSS前處理語言)、flex、Input Number customize\nOthers: google fonts\n開發歷程  使用Vue做開發(我就懶)，讓vue做畫面渲染並使開發過程專注在程式邏輯上 時間上透過setInterval去執行60秒的倒數,時間倒數到0時清除週期性定時器Interval並跳至最後一個頁面，當使用者在最後的頁面點擊try again時重新開始遊戲 使用Math.random亂數產生題目，使用者送出答案時除了對答案還會依據目前所剩時間給予相對應的分數並依所剩時間產生相對應難度的題目 新增小功能為透過localStorage去儲存自己遊戲的最高分,這是純前端的作法，如果有跟後端配合的話可以延伸至分數排行榜等等\u0026hellip;  Input Number customize 我們要讓使用者輸入數字時會使用 \u0026lt;input type=\u0026quot;number\u0026quot;\u0026gt;這個HTML表單元件,這個元件會有預設的上下箭頭讓使用者去調整數字,但是元件的上下箭頭個人認為跟整體設計非常不搭所以移除掉，現在來看一下CSS語法吧\ninput[type=\u0026#34;number\u0026#34;] { width: 255px; height: 131px; outline: none; font-size: 112px; font-weight: bold; text-align: center; border: none; /* default style firefox */ -moz-appearance: textfield; /* default style safari、chrome、ie */ \u0026amp;::-webkit-inner-spin-button,\u0026amp;::-webkit-outer-spin-button { appearance: none; -webkit-appearance: none; margin: 0; } } 註:在客製化樣式方面發現firefox很常需要下跟其他瀏覽器不同的前綴字，想客製化元件樣式的時候要注意一下\nlocalStorage、sessionStorage   localStorage以及sessionStorage為客戶端的資料儲存技術容量大小都為5MB,透過設定key:value的方式來儲存資料進瀏覽器，跟cookie不同的是在與server溝通時不會被自動帶入\n  localStorage以及sessionStorage兩者之間唯一的不同就是localStorage如果使用者不刪除資料該筆資料會永遠存在在瀏覽器內但sessionStorage只要該分頁關閉時資料就會清除掉\n  // localStorage  localStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); localStorage.getItem(\u0026#39;myName\u0026#39;); localStorage.removeItem(\u0026#39;myName\u0026#39;); localStorage.clear(); // sessionStorage  sessionStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); sessionStorage.getItem(\u0026#39;myName\u0026#39;); sessionStorage.removeItem(\u0026#39;myName\u0026#39;); sessionStorage.clear(); 透過localStorage去儲存玩家遊戲的分數，如果當次分數比上次高就會儲存進去\n安全性 當我們要使用Vue時大多習慣這樣寫\nconst app = new Vue({...}); 但這樣使用者其實可以打開瀏覽器的console端去把分數改掉\n可以把const app移除掉讓使用者沒辦法透過console端去修改資料\n但是這樣還不夠，使用者可以透過瀏覽器去修改localStorage的值去更改最高紀錄的分數\n這時候我們可以新增一個storage的事件監聽,只要在遊戲進行時偵測到localStorage的值被修改就將分數歸0並重新開始遊戲，只有在遊戲結束時分數要進行更新時允許更新localStorage,更新完後一樣禁止再次修改localStorage的值\nfunction security(){ window.addEventListener(\u0026#39;storage\u0026#39;,()=\u0026gt;{ if(this.higest !== localStorage.getItem(\u0026#34;higestscore\u0026#34;)){ alert(\u0026#34;偵測到分數被修改，遊戲積分歸0\u0026#34;); localStorage.setItem(\u0026#34;higestscore\u0026#34;,0); // history.go(0);  this.try_again(); } }); } 因為程式內部的賦值也是更新,所以遊戲結束要賦值前記得先將事件監聽移除，等到程式內部的更新完成後再重新註冊一次事件監聽\nwindow.removeEventListener(\u0026#39;storage\u0026#39;); 我個人是透過修改資料內的狀態來重新開始遊戲,不過可能會有人想透過history.go(0)或是window.reload()等方式重新開始遊戲，但是這在codepen會有問題,建議要試的可以將自己的檔案下載下來後再測試\ncodepen針對reload頁面的說明我放在參考資料內\nDemo 連結  參考資料: Input Number 客製化\nWeb Storage MDN\nlocalStorage MDN\nsessionStorage MDN\nreferred-from-pen-message\n","permalink":"https://bjmqfg83.github.io/blog/mathgame/","tags":["javascript","程式學習"],"title":"60秒算數遊戲-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : Vue、axios、For迴圈、Regular expressions、Array\nCSS: SCSS(CSS前處理語言)、flex、customize scrollbar\nOthers: google fonts、政府資料開放平台-空氣品質指標(AQI)\n開發歷程 想要專注在邏輯上所以使用框架開發,當資料更新時由Vue負責畫面渲染\n資料的取得使用axios這個套件串接政府資料開放平台的API，另外頁面的部分做了一個假的selection方便客製化CSS樣式，其餘js程式邏輯使用forEach過濾出符合條件的資料、正規表示法調整更新時間顯示的格式\nXMLHttpRequest 在提交表單資料、串接API這種非同步行為時會希望過程中仍可以對網頁進行操作及瀏覽\n這時候我們可以透過XMLHttpRequest讓網頁在進行非同步的操作時不會卡住或是重整\n//Step 1 創建異步物件  var xhr = new XMLHttpRequest(); //可以簡稱xhr物件 //Step 2 創建異步請求 // method為http請求(get、post...)、url為請求路徑、async為為非同步設定,true為非同步、false為同步 xhr.open(method, url, async); //3.設定監聽事件 // 當xhr物件接受到server的嚮應且響應狀態為200(ok)時進行後續處理 xhr.onreadystatechange = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // 取得響應的訊息  var resText = xhr.responseText; } } // 4.送出請求，send參數除post以外都給null xhr.send(null); 如果是post請求的話需要額外設定RequestHeader，告知server要提交的資料類型並把資料放置send提交\n// 以表單資料為例 xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); var msg = \u0026#39;data1=\u0026#39; + 資料1 +\u0026#39;\u0026amp;\u0026#39;+ \u0026#39;data2\u0026#39; + 資料2... ; xhr.send(msg); 註: 雖然是叫「XML」HttpRequest但也可以使用純文字或是JSON格式的資料\nPromise 在簡單的專案可能還沒關係，但如果專案的需求須要進行多個請求或是要在請求後進行很多程式的處理的話可能會變成下面這樣\n圖片來源: Node 7.6 + Koa 2: asynchronous flow control made right\n這種波動拳的樣子有個別稱叫「Callback hell 回調地獄」，這會造成日後程式維護、擴充上的不便，我們可以透過ES6的Promise來改善,這邊簡單概述一下\nPromise有以下三種狀態\n 擱置(pending)：初始狀態，表示操作進行中 實現(fulfilled) ：表示操作成功，執行resolve(),可透過then查看結果 拒絕(rejected)： 表示操作失敗，執行reject(),可透過catch查看結果  圖片來源: Promise MDN\nfunction PromiseFn() { return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); // 可以把api_key後面的參數改掉刻意引發CORS的錯誤來執行reject  xhr.open(\u0026#34;get\u0026#34;,\u0026#34;https://data.epa.gov.tw/api/v1/aqx_p_432?limit=1000\u0026amp;api_key=9be7b239-557b-4c10-9775-78cadfc555e9\u0026amp;format=json\u0026#34;); // xhr.onreadystatechange可用onload取代  xhr.onload = function() { resolve(JSON.parse(xhr.responseText)); } xhr.onerror = function(){ reject(xhr); } xhr.send(null); }); } PromiseFn() .then(function(res){ ... return PromiseFn(); }).then(function(res2){ ... return PromiseFn(); }).then(function(res3){ ... }).catch(function(error){ ... }); 這樣就避免了波動拳的產生，後續要繼續進行非同步操作時透過return一個Promise的方式進續進行\nPromise還有其他如Promise.all()、Promise.race()等等的方法\u0026hellip;甚至在ES7版本有更好用的Async/Await可以用同步的思維去做非同步的操作，有興趣的朋友可以研究看看\nFetch API 以前如果想要簡化XMLHttpRequest的寫法通常都會使用jQuery的ajax來做，現在在HTML5的標準內我們有原生的Fetch API可以使用\nFetch API有幾點特性\n 使用Promise做回應 使用then做下一步處理、catch作錯誤處理 一開始的回傳為ReadableStream，需要針對不同的資料類型使用對應方法獲取資料ex:json()、text()、blob()\u0026hellip; 只要server有響應不論status code是404或是500Promise的狀態都會是fulfilled而不是rejected，這部分需要額外做處理  現在看一下程式碼\nfetch(\u0026#39;https://jsonplaceholder.typicode.com/todos/1\u0026#39;) .then(res =\u0026gt; { console.log(res); // response的body內可以看到ReadableStream  if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳  }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }) .then(json =\u0026gt; console.log(json)) .catch(err =\u0026gt; { console.error(\u0026#39;錯誤\u0026#39;, err); }); POST方法一樣要設定header跟body\nfetch(url, { method: \u0026#39;POST\u0026#39;, // headers 加入 json 格式  headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, // body 將 json 轉字串送出  body: JSON.stringify({ data_A: \u0026#39;xxxx\u0026#39;, data_B: \u0026#39;xxxx\u0026#39; }).then(res =\u0026gt;{ if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳  }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }).then(jsonData =\u0026gt; {console.log(jsonData)}; ).catch(err =\u0026gt; { console.log(\u0026#39;錯誤:\u0026#39;, err); }) CORS CORS全稱為Cross-Origin Resource Sharing 跨來源資源共享，瀏覽器基於安全性的考量會限制使用者存取其他來源的資源\n以下幾種情況會被當作不同來源\n 不同協定 ex: \u0026quot;https\u0026quot;、\u0026quot;http\u0026quot; 不同domain ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example_others.com\u0026quot; 不同port ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example.com:8080\u0026quot;  跟後端協作串接API時如果遇到CORS通常後端會去設定Access-Control-Allow-Origin來讓特定來源能夠存取資源或是乾脆使用*號(通配符)讓所有不同來源都能夠存取\n但如果要串接的是第三方的API的話可以參考一下六角助教寫的Google Apps Script這篇文章去試看看，大概的理解是CORS是因為瀏覽器請求非同源的資源所發生，那就不用瀏覽器去請求來規避這個問題\n我用新竹縣政府公務人員參訓人數這個API去試了之後沒問題，但是對於像是需要API_KEY金鑰的API如空氣品質指標(AQI)一樣還是會有CORS的問題發生，所以Google Apps Script只是一個暫時性的方式，實作上還是要因應情況去做調整\nAQI Demo連結  參考資料: ReadyState MDN\nPromise MDN\nFetch MDN\nOxxO STUDIO Fetch API 使用教學\n","permalink":"https://bjmqfg83.github.io/blog/air_quality/","tags":["javascript","程式學習"],"title":"全台空氣指標儀表板-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : For迴圈、Date、string、setInterval\nCSS: SCSS(CSS前處理語言)、Grid Layout\nOthers: google fonts\n開發歷程 這次的切版跟程式邏輯都不算複雜,麻煩的是要找Date().toLocaleString的參數設定,有需要的可以看看參考資料的連結，現在這邊來跟各位分享相關知識\n時間戳timestamp timestamp指的是從1970年1月1日0時0分0秒開始到現在總共經過多少豪秒數，可用於追蹤時間、計算時間差、日期排序等等\u0026hellip;，在js內可透過new Date().getTime()取得，不過在查詢資料的時候看到有人說是經過的「秒數」，但使用相關函式獲取到的到底是毫秒還是秒這部分可能跟程式語言、系統環境有關，javascript獲取到的是「毫秒數」、php獲取到的是「秒數」，有興趣的可以到epochconverter、unixtimestamp看看\nGMT、UTC GMT全稱為格林威治標準時間(Greenwich Mean Time)、UTC全稱為世界協調時間(Coordinated Universal Time),台灣所在的時區快八小時所以可以表示成「GMT+8」或是「UTC+8」，那至於GMT、UTC的差別詳細的可以參考泛科學的到底是 GMT+8 還是 UTC+8 ?，日常生活中兩者沒什麼區別可以混用,只是由於地球自轉速度在變慢導致GMT的1秒越來越長，UTC會在超過GMT快1秒時加入「閏秒」來抵消超前的量\nworld clock時區 要獲取指定地區的日期時間我們可使用Date物件的toLocaleString\nnew Date().toLocaleString([locales[, options]]) locales為語言環境，簡單來說是讓時間以該語言的格式顯示，比如說你locales給'zh-tw(台灣)'的話顯示的格式為\u0026quot;2021/2/10 下午1:42:31\u0026quot;，如果給'en-GB(英國)'的話顯示的格式為\u0026quot;10/02/2021, 13:48:17\u0026quot;，但這只是顯示的格式而已,時區還是在使用者所在的地區,如果要顯示別的時區的時間需要透過options做設定\noptions可以設定時區以及年、月、日等等的顯示格式，這邊列出有使用到的\n timeZone =\u0026gt; 設定要顯示的地區時間 hour12 =\u0026gt; 設定顯示是否為12小時制 year =\u0026gt; 設定顯示年分格式 month =\u0026gt; 設定顯示月份格式,可為英文或數字 day =\u0026gt; 設定顯示日期格式 hour =\u0026gt; 設定顯示小時格式 minute =\u0026gt; 設定顯示分鐘格式 注: locales、options內詳細的參數設定可以直接看最後面的參考資料\nJS程式邏輯 // 時區依序為美國、英國倫敦、曼谷、台北、澳洲雪梨  const timeZones = [ \u0026#34;America/New_York\u0026#34;, \u0026#34;Europe/London\u0026#34;, \u0026#34;Asia/Bangkok\u0026#34;, \u0026#34;Asia/Taipei\u0026#34;, \u0026#34;Australia/Sydney\u0026#34; ]; // toLocaleString options參數  const options = { timeZone: \u0026#34;Asia/Taipei\u0026#34;, // 時區設定台北  hour12: false, //不以12小時制顯示,會以24小時制顯示  year: \u0026#34;numeric\u0026#34;, //正常數字顯示  month: \u0026#34;short\u0026#34;, //short只會顯示三位英文 ex: February =\u0026gt; Feb  day: \u0026#34;2-digit\u0026#34;, //顯示兩位 ex: 1 =\u0026gt; 01  hour: \u0026#34;2-digit\u0026#34;, //顯示兩位  minute: \u0026#34;2-digit\u0026#34; //顯示兩位  }; function world_clock() { timeZones.forEach((item, index) =\u0026gt; { var temp_clockInfo = \u0026#34;\u0026#34;; var temp_dateInfo = \u0026#34;\u0026#34;; options.timeZone = item; // 時區使用英國(en-GB)顯示結果就會是日、月、年、時間  temp_clockInfo = new Date().toLocaleString(\u0026#34;en-GB\u0026#34;, options); //月份後面添加「. 」後重新拼接日期字串  temp_dateInfo = temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[0] + \u0026#34; \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[1] + \u0026#34;. \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[2]; //更新年月日的元素  document.querySelectorAll(\u0026#34;.location-info .location-date\u0026#34;)[index].innerText = temp_dateInfo; //依格式中的「,」分割出時分後更新DOM,透過index下標去找目標元素  document.querySelectorAll(\u0026#34;.location-info \u0026gt; div:nth-of-type(2)\u0026#34;)[index].innerText = temp_clockInfo.split(\u0026#34;,\u0026#34;)[1].trim(); }); } world_clock(); // 每秒鐘調用一次判斷getSeconds()是否為59，為59示1分鐘要到可以調用函數更新時間  var clock_timer = setInterval(function(){ if(new Date().getSeconds()===59){ world_clock(); } },1000); world clock codepen連結  參考資料: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nhttps://blog.techbridge.cc/2020/12/26/javascript-date-time-and-timezone/\n","permalink":"https://bjmqfg83.github.io/blog/world_clock/","tags":["javascript","程式學習"],"title":"WORLD CLOCK-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : Vue、正規表達式、String(substring、replace、split)、For迴圈、Array(reverse)\nCSS: SCSS(CSS前處理語言)、Customize Scrollbar\n開發歷程 這次寫題目時想順便複習FrameWork所以使用了Vue做開發，花了滿多時間想怎麼在千分位前加上「,」以及避免計算結果出現「undefined」、「NAN」\n千分位資料處理 整數位數超過三位時要加上千分位符「,」需要使用正規表達式、字串、陣列的方法來處理\n//當計算機輸入到加、減、乘、除時對運算符前的數字做千分位符的處理 // +號在正規表達式有特定意思所以要單純匹配需在前面加上「反斜線」 // g表示要找出所有符合條件的結果，不加的話只會找出第一筆符合條件的結果就結束 const comma_rule = /(\\+|-|×|÷)/g; let prev_comma = \u0026#34;\u0026#34;; //整數位 let after_comma = \u0026#34;\u0026#34;; //小數位 let comma_val = \u0026#34;\u0026#34;; //加上千分位的結果 function compute_comma(){ comma_arr = result.split(comma_rule); //依據規則分隔出符合條件的陣列資料  comma_arr.forEach((item, index) =\u0026gt; { if (!isNaN(parseFloat(item))) { // 判斷是否為加、減、乘、除,只處理非NAN的資料  prev_comma = (item.split(\u0026#34;.\u0026#34;)[0] || \u0026#34;\u0026#34;).split(\u0026#34;\u0026#34;).reverse(); //整數位轉成陣列處理  after_comma = item.split(\u0026#34;.\u0026#34;)[1] || \u0026#34;\u0026#34;; //小數點先暫存進變數等處理完整數之後再整合進去  comma_val = \u0026#34;\u0026#34;; //每次迴圈前先清空  //前面的reverse()用來方便拼接字串  //ex:[3,8,5,6].reverse() =\u0026gt; [6,5,8,3]  for (let i = 0; i \u0026lt; prev_comma.length; i++) { //當到第四位時在第三位前加上千分位符「,」  if (i % 3 === 0 \u0026amp;\u0026amp; i !== 0) { // step 4 =\u0026gt; \u0026#34;3\u0026#34;+\u0026#34;,\u0026#34;+\u0026#34;856\u0026#34;  comma_val = prev_comma[i] + \u0026#34;,\u0026#34; + comma_val; //非第四位則單純拼接  } else { // step 1 =\u0026gt; \u0026#34;6\u0026#34;+ \u0026#34;\u0026#34;、step 2 =\u0026gt; \u0026#34;5\u0026#34; + \u0026#34;6\u0026#34;、step 3 =\u0026gt; \u0026#34;8\u0026#34; + \u0026#34;56\u0026#34;  comma_val = prev_comma[i] + comma_val; } } } }); } 其餘的輸入規則如避免「NAN」、「undefined」讀者可以稍微思考一下如何處理，這邊就不贅述\nScrollbar客製化 稍微看過其他人做的計算機在位數過多時滿多都是使用js調整字體大小來避免畫面破格,但我個人不太想要調整字體大小所以選擇用css處理位數過多的問題，在畫面位數過多時會出現scrollbar可以滑動，可能會有人覺得瀏覽器預設的不是很好看，這部分可以透過css去調整\n注:scrollbar的調整Firefox要額外寫\nFirefox scrollbar-width: auto | thin | none | 1em | inherit | initial | unset ; scrollbar-color: auto | dark | light | color1(滾動條本身的顏色thumb) color2(滾動條外容器的顏色track); 注: color1、color2可以用關鍵字(red、blue\u0026hellip;)或是色碼\nChrome、IE Edge、Safari /* 屬性前要加::-webkit-前綴字 */ ::-webkit-scrollbar: width | height ; ::-webkit-scrollbar-thumb: background | box-shadow | ... ; 注: 這邊簡單列出有使用到的，有需要的話可參考底下連結\n計算機 codepen連結  參考資料: https://css-tricks.com/custom-scrollbars-in-webkit/\nhttps://css-tricks.com/examples/WebKitScrollbars/\nhttps://stackoverflow.com/questions/6165472/custom-css-scrollbar-for-firefox/53739309#53739309\nhttps://github.com/Aris-t2/CustomCSSforFx/issues/160\n","permalink":"https://bjmqfg83.github.io/blog/hex_calculator/","tags":["javascript","程式學習"],"title":"計算機Calculator-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術: JS : Const變數、Date物件、SetInterval、Template literals樣板字串\nCSS: SCSS(CSS前處理語言)、clip-path\n開發歷程: JS的部分透過Date物件獲取當前的時間、setInterval更新時間並且在內部判斷指針的轉動、Template literals用於方便將計算指出來的旋轉角度整合進字串內\nCSS的部分使用SCSS變數去存取顏色、mixin存取會大量使用到的CSS屬性、clip-path去繪製多邊形及秒針\n這次在CSS的部分卡了滿長的一段時間，主要是花在使用純CSS刻出秒針以及多邊形花了大部分的時間，其餘的排版、程式邏輯的部分相對來說不算太複雜\n在這邊簡單的跟大家分享一下怎麼透過clip-path去繪製時鐘所需的圖形\nclip-path clip-path會透過裁減的方式在元素內創建可顯示的區塊，顯示區塊外的部分則隱藏，本身有提供circle(圓形)、ellipse(橢圓形)、inset(內置矩形)、polygon(多邊形)等等的方式創建圖形\n要創建秒針跟多邊形會需要使用到polygon，polygon可以設定多個「點」，點跟點之間會有線連接在一起形成多邊形，透過X(水平)、Y(垂直)來設定點的位置，單位可以使用「px」或是「百分比」，秒針針頭的部分另外做之後在外層用一個元素包起來就好\n解說圖就別太計較設計了，真的不太會畫畫\u0026hellip;\n時鐘 codepen連結  clip-path補充 在前面有提到過clip-path會有顯示的區塊及隱藏的區塊，我們可以透過這個遮罩的效果搭配CSS做出遮蓋文字的特效\n我們需要透過inset內置矩形去做，inset可給2個值(上下、左右)或是4個值(上、右、下、左)，設定該方向的值就會由該方向由外往內推，單位同樣可以用px或是百分比\n文字動態 codepen連結  參考資料: https://www.oxxostudio.tw/articles/201503/css-clip-path.html\nhttps://andyyou.github.io/2016/06/28/css-clip-path/\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path\nhttps://css-tricks.com/almanac/properties/c/clip-path/\n","permalink":"https://bjmqfg83.github.io/blog/clock/","tags":["javascript","程式學習"],"title":"時鐘clock-Javascript新手地下城"},{"categories":["javascript"],"contents":"前一陣子同事丟了一個問題要我動動腦練習寫一個迴圈動態，規則如下\n 以中心點做為起始點 不斷重複 不論版面是3x3、5x5、7x7、9x9甚至是以上都要能夠正常執行  開發歷程:\n開發的時候在元素上標示上數字可以在開發時幫忙找出中點以及跑迴圈的相關邏輯,建議標上去\n接下來就是找出所需的相關資訊，稍後會在說明要迴圈數、轉折點的主因\n 起始點 迴圈數 轉折點  起始點直接除以2取最小整數即可\nvar now_pos = Math.floor(元素總數 / 2); 迴圈數思考一下可以發現3x3是跑一圈迴圈、5x5兩圈、7x7三圈\u0026hellip;\n由此得出以下關係\nvar looptimes = (Math.sqrt(元素總數) - 1) / 2; 轉折點是當中非常重要的關鍵，因為會需要轉折點讓程式判斷跑的方向\n我是取中心點的左右斜對角作為轉折點，並透過迴圈數求出所有轉折點\nfor (var i = 1; i \u0026lt;= looptimes; i++) { // 最後-1是為了對應陣列下標從0開始  // 左上  cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) + 1) - 1); // 右上  cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) - 1) - 1); //右下  cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) + 1) - 1); // 左下  cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) - 1) - 1); } 求出所有的轉折點後可以開始做迴圈的邏輯判斷了\n計算當前所在的點 (最開始是中心點) 與轉折點之間的差值之後求差值得商數及餘數\n 餘數作為左右的判斷 商數作為上下的判斷 當前的點大於轉折點迴圈的方向就為左或上 當前的點小於轉折點迴圈的方向就為右或下  重複執行的部分則透過setInterval去做就可以了\n在測試的時候可以改成7x7或9x9看看，一樣可以正常的執行\n之後針對動態如果還有什麼問題都歡迎來找我討論~\n執行結果:\n ","permalink":"https://bjmqfg83.github.io/blog/looping_ani/","tags":["javascript","程式學習"],"title":"愛的魔力轉圈圈-不斷重複的迴圈動態"},{"categories":["hugo"],"contents":"如果想要讓訪客針對你的文章發表評論的話我們可以透過 Disqus 或是 Utterances 快速建立評論留言板\n其實一開始建立個人部落格時評論的套件我使用的是disqus，但是我丟到google的 PageSpeed 測試時發現整個網頁的載入時間有大半以上都花在disqus上面且有很多載入後卻沒有使用到，所以之後便決定改用utterances\n另外上網查了相關的文章說disqus有個資相關的問題，文章結尾會附上相關連結有興趣的可以看一下\nUtterances是什麼? utterances是一個基於github issue的套件，其原理是在github上建立一個公開的repo讓訪客可以針對文章在repo上建立相關的issue，接下來就來跟大家介紹如何在頁面上添加utterances\n 在github上建立公開的repository  到utterances安裝頁面後點選install  選擇要安裝utterances的github repo  之後在utterances官網下可以找到區塊進行設置  選擇想要的主題樣式  將產生的script複製下來後放到想要的地方  這樣就完成utterances的設置了\n但要注意utterances是基於github issue所以留言的人需要有github帳號才可以留言\n如果有問題的話歡迎在底下留言\n補充資料 移除disqus留言系統\nThe Problem With Disqus\nWhy I Deleted Disqus and Why You Should Too\n","permalink":"https://bjmqfg83.github.io/blog/hugo_unnerances/","tags":["程式學習"],"title":"如何在hugo上安裝utterances?"},{"categories":["css"],"contents":"當內部元素的寬度超過容器寬度時我們可以使用flex-shrink將內部元素的寬度縮減讓元素不會超過容器\n那flex-shrink到底是怎麼做寬度的縮減?\n基礎公式如下\n元素縮減的寬度 = 超出的總寬度 * 該元素的flex-shrink / 各元素flex-shrink總和\n來看一下code的部分\n Javascript的部分單純只是獲取元素寬度並放在元素上,可以不看\nHTML、CSS原始碼的部分\n1.元素外部容器的寬度為600px\n2.內部元素每個為300px\n3.flex-shrink為1、2、1\n由於內部元素的總寬度超過容器300px,每個設有flex-shrink的元素寬度都會做縮減,用公式算一下每個元素縮減的多少\n元素1\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n150px = 超出的寬度 300px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素寬度為225px、150px、225px,看起來公式沒什麼問題\n如果元素寬度不相同的情況下呢?\n我們先將內部元素寬度設為300px、250px、150px而flex-shrink跟原本一樣為1、2、1\n我們來用公式計算一下\n元素1\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n50px = 超出的寬度 100px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n計算出來的寬度為275px、200px、125px\n那我們現在實際來看一下程式碼\n 實際計算出來的寬為269px、197px、134px,跟用公式算出來的不一樣\n其實我們在網路上看到很多講flex-shrink公式是被簡化過的,只有當元素的寬度都一樣才可以這樣用,實際的公式需要將元素寬度考量進去\n首先先將元素的寬度乘以flex-shrink相加來計算總權重\n總權重 950 = 300px * 1 + 250px * 2 + 150px * 1\n修正的公式如下:\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n現在來重新計算縮減的寬度\n元素1\n31.57px = 100px * 1 * 300px / 950\n元素2\n52.63px = 100px * 2 * 250px / 950\n元素3\n15.78px = 100px * 1 * 150px / 950\n計算出來的寬度為268.43px、197.39px、134.22px\n實際來看一下程式碼\n 發現計算出來的寬度有小數點的誤差,不過這點可以忽略不計\n補充章節 如果flex-shrink小於1的狀況?\n如果flex-shrink總和小於1則在收縮寬度時不會收縮超出的總寬度,而是會收縮flex-shrink相對於1的比例\n拿上面的例子做修改\n將flex-shrink設為0.1、0.2、0.3\n收縮的總寬度為超出的總寬度100px * 0.6 / 1 = 60px,帶入原先的公式\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n計算新的總權重\n125px = 300px * 0.1 + 250px * 0.2 + 150px * 0.3\n元素1\n14.4px = 60px * 0.1 * 300px / 125\n元素2\n24px = 60px * 0.2 * 250px / 125\n元素3\n21.6px = 60px * 0.3 * 150px / 125\n計算出來的寬度為 285.6px、226px、128.4px\n跟實際的結果會有有零點幾的誤差\n 這篇與其說是文章倒不如說是寫筆記會比較正確\n複習flex時剛好有這個疑問就爬文+問人\n希望能幫助一樣有這個疑問的人\n補充資料連結 卡斯柏-圖解：CSS Flex 屬性一點也不難\n詳解flex-grow與flex-shrink\n","permalink":"https://bjmqfg83.github.io/blog/flex-shrink/","tags":["css","程式學習"],"title":"Css flex-shrink是怎麼縮的?"},{"categories":["javascript"],"contents":"最近想複習HTML、CSS、Javascript的基礎概念\n所以開始寫六角學院的新手地下城題目\n使用技術:\nJS : let變數、Template literals樣板字串、for迴圈\nCSS: SCSS(CSS前處理語言)、BEM風格規範(其實這我不確定名稱是否有完全符合BEM的規範)\n開發歷程:\n寫的時候覺得麻煩的地方並不在程式邏輯的地方,反而在思考HTML結構、CSS變數命名的地方佔據的大半的時間,希望日後切板的技術可以越來越純熟\n 程式碼:\nhttps://codepen.io/mgnlhdsl/full/NWGObqo\nhttps://bjmqfg83.github.io/multiplication_table/multiplication_table\n","permalink":"https://bjmqfg83.github.io/blog/multiplication_table/","tags":["javascript","程式學習"],"title":"99乘法表-Javascript新手地下城"}]
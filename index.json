[{"categories":["css"],"contents":"從去年起tailwind在台灣熱度越來越高,另外最近也在HISKIO上買了tailwind的課程學習,所以想說也來蹭一下分享一下所學順便兼做筆記方便日後複習\ntailwindcss解決什麼問題? tailwindcss是一個utility-first的css框架,而且由於tailwind將絕大部分的css樣式通通寫成class使用(ex:mt、flex、grid\u0026hellip;),所以可以讓工程師在寫html的時候一併處理樣式而幾乎不用寫額外的css,跟bootstrap之間最大的不同是tailwind沒有像是「Accordion」、「Dropdown」之類的組件,全部都是功能性的class，另外由於使用tailwind等同於直接在html上寫style,所以可以避免樣式幾乎相同卻硬是要命名不同的class,大大減少多餘的css\n註:想要玩一下tailwind的話可以先到tailwindplay嚐嚐鮮\ntailwindcss配置 tailwind官方有提供三種配置方式\ncdn tailwind cli npm CDN \u0026lt;link href=\u0026#34;https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; 不過官方不推薦使用這個方式,主要是因為以下原因\n無法客製化tailwind的主題 無法使用@apply、@variants等等的指令 無法開啟如group-focus這種額外的變數 無法安裝第三方的plugin 無法進行tree shake移除沒使用的樣式 個人認為最要命的是最後一點，雖然如果沒有要客製化的話直接使用也不是不行,但是tailwind沒做purge的話總共有3MB的大小,丟到vscode看將近有20萬行的css原始碼,這麼大包會出事的阿\u0026hellip;\ntailwind cli(Node.js版本要在12.13.0以上) 使用以下指定建立tailwind.css (-o為output)\nnpx tailwindcss -o tailwind.css 要讓自己寫的css跟tailwind一起編譯的話要先將tailwind的基礎樣式用@tailwind引入至自定義的css檔案內\n/* ./src/index.css */ @tailwind base; /* 基礎樣式 */ @tailwind components; /* 模組樣式 */ @tailwind utilities; /* 共用樣式 */ @layer base { ... } @layer components { ... } 再使用以下指令匯出css( -i為input、-o為output)\nnpx tailwindcss -i ./src/index.css -o ./dist/tailwind.css 可透過tailwind.config.js對tailwind本身進行設定,用以下指令建立tailwind.config.js\nnpx tailwindcss init tailwind.config.js\nmodule.exports = { purge: [], darkMode: false, // 也可以是 \u0026#39;media\u0026#39; 或 \u0026#39;class\u0026#39; theme: { extend: {}, }, variants: {}, plugins: [], } 使用tailwind cli時config檔會自動被讀取,另外如果要以production mode建置的話要在指令前面加上「NODE_ENV=production」這個環境變數\nNODE_ENV=production npx tailwindcss -i ./src/tailwind.css -o ./dist/tailwind.css --minify 註:\u0026ndash;minify會把css檔案內的間距、空白移除掉,進一步壓縮css檔案的大小\n註:windows作業系統並不自帶NODE_ENV,使用windows的話記得要額外下載\n以PostCSS插件的方式來安裝Tailwind 透過Postcss來安裝tailwind，這個方式還可以透過webpack等打包工具整合其他第三方插件來協助開發\n透過npm載入tailwindcss、postcss、autoprefixer\nnpm install -D tailwindcss@latest postcss@latest autoprefixer@latest postcss是一個加強處理css的js plugin,包括依照Can i use添加瀏覽器前綴、使用新的css功能或是做圖片的處理,我們透過postcss整合tailwind並使用autoprefixer去添加瀏覽器前綴\n我本身是使用webpack打包,所以為了要讓webpack能夠讀取解析postcss需要載入postcss loader\nnpm install -D postcss-loader 新增postcss.config.js、tailwind.config.js、webpack.config.js\npostcss.config.js\nmodule.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;) ] } tailwind.config.js\nmodule.exports = { purge: [], darkMode: false, // 也可以是 \u0026#39;media\u0026#39; 或 \u0026#39;class\u0026#39; theme: { extend: {}, }, variants: {}, plugins: [], } 跟tailwind cli一樣把tailwind的樣式引入到自訂義的index.css內\n/* ./src/index.css */ @tailwind base; /* 基礎樣式 */ @tailwind components; /* 模組樣式 */ @tailwind utilities; /* 共用樣式 */ @layer base { ... } @layer components { ... } webpack.config.js配置\nconst path = require(\u0026#39;path\u0026#39;); module.exports = { entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;index.js\u0026#39;, }, module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;postcss-loader\u0026#39;], },... ] } } 註: 記得把index.css給import進index.js\ntailwind css intellisense 如果是用vscode開發可以安裝這個插件,在寫class時會出現提示\npurge css tailwind會把沒使用到的樣式移除掉來減少產生的css檔案大小,但是tailwind並不知道有哪些檔案內有使用到tailwind的class,所以如果有檔案使用tailwind的話要在purge內加上content的物件,這樣tailwind就會透過content內的路徑去看這些路徑內的檔案並把檔案內有使用到的class保留下來\nmodule.exports = { purge: { content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.{html,js}\u0026#39;] } } 有無purge的差別真的滿大的\u0026hellip; 雖然tailwind很貼心的把沒有使用到的css移除掉但是這會衍伸一個問題,如果今天html是透過後台編輯器產生的話就有可能使用到被移除掉的class,為了避免這個問題這時候我們可以在config檔內加上safelist,tailwind在產生css時會把safelist內的class保留下來\nmodule.exports = { purge: { content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.{html,js}\u0026#39;], safelist: [ \u0026#39;bg-blue-500\u0026#39;, \u0026#39;text-center\u0026#39;, \u0026#39;hover:opacity-100\u0026#39;, } } 補充一下雖然tailwind第三版還沒有正式釋出不過第三版purge被移除掉了,content跟safelist直接寫就可以了\nmodule.exports = { content: [\u0026#39;./src/**/*.html\u0026#39;, \u0026#39;./src/**/*.{html,js}\u0026#39;], safelist: [ \u0026#39;bg-blue-500\u0026#39;, \u0026#39;text-center\u0026#39;, \u0026#39;hover:opacity-100\u0026#39;, ] } base base裡面主要是寫基礎的樣式,如h1的size以及margin之類的\n@layer base { h1{ font-size: 20px; margin: 1rem 0; } } @apply 可能會有人覺得使用tailwind會讓class變得又臭又長,這時候我們可以透過tailwind的components、@apply將多個class群組起來\n@layer components { .card{ @apply rounded-lg mt-4 px-4 py-3 bg-fb-card; } } 建議只將需要共用的class群組起來就好了\ndark Mode module.exports = { darkMode: \u0026#39;false\u0026#39;, //參數可選填media or class } dark mode就是所謂的夜間模式,接受「media」、「class」的字串參數,media會以電腦系統的設定來轉換夜間模式而class則是使用手動的方式轉換夜間模式 ,在tailwindplay試一下會發現tailwind就是在html上添加dark的class\n@layer base { body { @apply dark:bg-black; } } 需要在夜間模式顯示的樣式可以在html標籤內或是在自定義的index.css裡的base裡面寫「dark: + utility class」\n手動模式要透過js的click事件在html上添加dark的class\nvar light_mode_btn = document.getElementById(\u0026#39;light\u0026#39;) var dark_mode_btn = document.getElementById(\u0026#39;dark\u0026#39;) light_mode_btn.addEventListener(\u0026#39;click\u0026#39;, function () { document.documentElement.classList.remove(\u0026#39;dark\u0026#39;) }) dark_mode_btn.addEventListener(\u0026#39;click\u0026#39;, function () { document.documentElement.classList.add(\u0026#39;dark\u0026#39;) }) variant變體 variant又有人稱為偽類變體,所謂的偽類就是css裡的「:hover」、「:active」、「:focus」等\u0026hellip;可以添加互動功能的pseudo-class，在tailwind裡面可以直接在html上寫上variant來增加頁面的互動效果,寫法是「variant: + utility class」\n\u0026lt;input class=\u0026#34;focus:bg-white hover:bg-black focus:border-white hover:border-black\u0026#34;\u0026gt; 在tailwindcss推出JIT之後只要JIT mode有開啟那麼所有class的variant都可以直接使用,但如果使用的是舊版本的tailwind(v1.96以前)又或是新版本的tailwindcss但是沒開啟JIT mode的話就要注意不是所有class的variant預設都是開啟的,可以從Configuring Variants裡面去看tailwind有支援的variant跟預設有開啟的variant\ncustomize自定義 我們要添加自定義的樣式需要在tailwind.config.js裡面預先寫,記得一定要寫在extend裡面不然會把原先tailwind裡相對應的utility class整個洗掉\u0026hellip;\nmodule.exports = { theme: { extend: { screens: {}, spacing:{}, colors: {}, }, } } 自定義的範圍很廣,可以試RWD斷點(screens)、顏色(colors)、間距(spacing)\u0026hellip;，相關的填寫方式直接看官網會比較快，不過每次要自定義樣式就要在tailwind.config.js裡面預先寫其實是有點麻煩\u0026hellip;，這時候tailwindcss在2.1版後推出了just in time的功能\nJIT(v2.1+) 補充資料 最後補充一下本身在使用webpack + tailwindcss時除了tailwind.config.js以外安裝的套件以及配置\npackage.json\n{ \u0026#34;name\u0026#34;: \u0026#34;tailwindProject\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development webpack serve --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=production webpack\u0026#34;, }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@babel/core\u0026#34;: \u0026#34;^7.14.6\u0026#34;,// 將js分析成ast,方便各個插件分析語法處理 \u0026#34;@babel/preset-env\u0026#34;: \u0026#34;^7.14.5\u0026#34;, // 將尚未被大部分瀏覽器支援的js語法轉換成能被瀏覽器支援的語法，以及讓較舊的瀏覽器也能支援大部分瀏覽器能支援的語法 \u0026#34;autoprefixer\u0026#34;: \u0026#34;^10.2.6\u0026#34;, // 給css添加瀏覽器前綴字 \u0026#34;babel-loader\u0026#34;: \u0026#34;^8.2.2\u0026#34;, // 使webpack可以讀懂babel \u0026#34;clean-webpack-plugin\u0026#34;: \u0026#34;^4.0.0-alpha.0\u0026#34;, // 打包前先將output資料夾清空 \u0026#34;compression-webpack-plugin\u0026#34;: \u0026#34;^8.0.0\u0026#34;, //將檔案進行壓縮產生壓縮檔 \u0026#34;copy-webpack-plugin\u0026#34;: \u0026#34;^9.0.0\u0026#34;,// 將src內特定資料夾的檔案複製到dist內的特定資料夾(名稱可自定義也可指定多組) \u0026#34;cross-env\u0026#34;: \u0026#34;^7.0.3\u0026#34;, // windows系統不自帶cross-env環境變數時安裝 \u0026#34;css-loader\u0026#34;: \u0026#34;^5.2.6\u0026#34;, // 使webpack可以讀懂css \u0026#34;cssnano\u0026#34;: \u0026#34;^5.0.8\u0026#34;, // 移除css內的空白 \u0026#34;html-webpack-plugin\u0026#34;: \u0026#34;^5.3.1\u0026#34;, // 將html輸出至dist資料夾內並在html內引入js檔案 \u0026#34;mini-css-extract-plugin\u0026#34;: \u0026#34;^1.6.0\u0026#34;, // 將css抽離成單獨的css檔案並在html內引入css檔案 \u0026#34;postcss\u0026#34;: \u0026#34;^8.3.5\u0026#34;, // 加強處理css,包括添加前綴、將新語法轉換成通用的舊語法 \u0026#34;postcss-loader\u0026#34;: \u0026#34;^6.1.0\u0026#34;, // 使webpack可以讀懂postcss \u0026#34;tailwindcss\u0026#34;: \u0026#34;^2.2.4\u0026#34;, // tailwindcss \u0026#34;webpack\u0026#34;: \u0026#34;^5.39.1\u0026#34;, //webpack打包工具 \u0026#34;webpack-cli\u0026#34;: \u0026#34;^4.7.2\u0026#34;, // webpack cli工具,提供操作webpack相關的cli指令 \u0026#34;webpack-dev-server\u0026#34;: \u0026#34;^3.11.2\u0026#34; // 透過webpack開啟本地server } } postcss.config.js\nmodule.exports = { plugins: [ require(\u0026#39;tailwindcss\u0026#39;), require(\u0026#39;autoprefixer\u0026#39;), require(\u0026#39;cssnano\u0026#39;)({ preset: \u0026#39;default\u0026#39;, }), ] } babel\nbabel.config.json\n{ \u0026#34;presets\u0026#34;: [\u0026#34;@babel/preset-env\u0026#34;] } .browserslistrc\n明確標示要支援的瀏覽器給如autoprefixer、Babel等等\u0026hellip;\nlast 2 versions not dead \u0026gt; 0.2% webpack.config.js\nconst HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); const { CleanWebpackPlugin } = require(\u0026#39;clean-webpack-plugin\u0026#39;); const CopyPlugin = require(\u0026#34;copy-webpack-plugin\u0026#34;); const CompressionPlugin = require(\u0026#34;compression-webpack-plugin\u0026#34;); const webpack = require(\u0026#39;webpack\u0026#39;) const path = require(\u0026#39;path\u0026#39;); module.exports = { target: \u0026#39;web\u0026#39;, entry: { index: \u0026#39;./src/index.js\u0026#39;, //多個entry可以以物件形式輸入 ... }, mode: process.env.NODE_ENV, // 如果是production mode會使用tree shaking,不會打包沒使用到的東西 output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;[name].[contenthash].js\u0026#39;, //name會去對應到entry裡物件的key值,hash為避免修改網頁時的快取 }, devServer: { compress: true, port: 8080 }, // loader module: { rules: [ { test: /\\.css$/i, use: [ MiniCssExtractPlugin.loader, { loader: \u0026#39;css-loader\u0026#39;, options: { importLoaders: 1, //如果在css檔案內使用@import要將importLoaders設為1,如果是sass則為2 } }, { loader: \u0026#39;postcss-loader\u0026#39; } ], }, { test: /\\.(jpe?g|png|gif)$/, // webpack5透過asset module來使用資源而不需載入loader, type: \u0026#39;asset/resource\u0026#39; // 將檔案輸出至output }, { test: /\\.m?js$/, exclude: /node_modules/, //babel處理時忽略node_modules use: { loader: \u0026#34;babel-loader\u0026#34;, } } ], }, // 插件 plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; }), new MiniCssExtractPlugin({ filename: \u0026#39;[name].[contenthash].css\u0026#39; }), new CleanWebpackPlugin(), new CopyPlugin({ patterns: [ { from: \u0026#34;./static\u0026#34;, to: \u0026#34;./static\u0026#34; }, ], }), new webpack.DefinePlugin({ // 在全域環境注入設定的變數,如果開發跟測試使用的config檔不同可以使用 // Definitions... PRODUCTION: JSON.stringify(false), VERSION: JSON.stringify(\u0026#39;5fa3b9\u0026#39;), BROWSER_SUPPORTS_HTML5: true }), new CompressionPlugin() ], devtool: \u0026#39;source-map\u0026#39; // source-map參數會在console端顯示原始的程式碼而非打包過後的程式碼方便debug } ","permalink":"https://bjmqfg83.github.io/blog/tailwindcss/","tags":["程式學習","css"],"title":"tailwindcss筆記"},{"categories":["javascript"],"contents":"之前在執行公司的專案時遇到兩個跟safari有關的問題\n透過js的click事件給元素添加class更改樣式以及執行transform後視覺上並無變化,但從開發者工具來看class以及裡面的樣式是有加上元素的 當使用者使用iphone播放影片「途中」突然待機後再開啟,畫面會直接停在待機前的畫面無法操作 這兩個問題嚴格意義上應該算一個問題,推測跟safari本身的渲染機制有關,不過不確定是什麼原因導致畫面沒有repaint就是了\u0026hellip;\n第一個問題是樣式沒有渲染上去,所以我們要做的是強行觸發瀏覽器的渲染機制,以下的屬性當js訪問時會先渲染dom後才會去獲得相關屬性\noffsetTop offsetLeft offsetWidth offsetHeight scrollTop scrollLeft scrollWidth scrollHeight clientTop clientLeft clientWidth clientHeight 我們先將元素的display設為「none」後訪問上述其中一個屬性再將元素的display設為「block」\nvar target = document.getElementById(\u0026#39;#target\u0026#39;); target.style.display=\u0026#39;none\u0026#39;; target.offsetHeight; target.style.display=\u0026#39;block\u0026#39;; 第二個問題要解決的話需要偵測手機是否待機，雖然Javascript沒辦法偵測手機是否待機,但是Web APIs裡有提供一個可以做為替代方式的API\nPage Visibility API Page Visibility API會在網頁處於背景或是對於使用者來說看不到的情形下觸發,測試過手機待機時同樣有效，首先註冊 「visibilitychange」 的事件監聽,當使用者待機觸發事件時再透過 「document.hidden」 檢查畫面對於使用者來說是否被隱藏,為true時暫停播放、為false時繼續播放\nJavascript程式邏輯 var videoplay_state = false; var target_video = document.querySelector(\u0026#39;#target-video\u0026#39;); var hidden, visibilityChange; target_video.addEventListener(\u0026#39;ended\u0026#39;,function(){ videoplay_state = true; }); if (typeof document.hidden !== undefined) { // Opera 12.10 and Firefox 18 and later support hidden = \u0026#39;hidden\u0026#39;; visibilityChange = \u0026#39;visibilitychange\u0026#39;; } else if (typeof document.msHidden !== undefined) { hidden = \u0026#39;msHidden\u0026#39;; visibilityChange = \u0026#39;msvisibilitychange\u0026#39;; } else if (typeof document.webkitHidden !== undefined) { hidden = \u0026#39;webkitHidden\u0026#39;; visibilityChange = \u0026#39;webkitvisibilitychange\u0026#39;; } // If the page is hidden, pause the video 、 if the page is shown, play the video function handleVisibilityChange() { if(videoplay_state){ return; } if (!document.hidden) { target_video.play(); } else { target_video.pause(); } } if (typeof document.addEventListener === undefined || hidden === undefined) { alert(\u0026#39;This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.\u0026#39;); } else { document.addEventListener(\u0026#39;visibilitychange\u0026#39;, handleVisibilityChange, false); } 另外影片播放結束後待機也有一個問題，當行動裝置上的Safari播放影片「結束」後再開啟會發現畫面整個是空白的，最快的解決方式是直接是在影片播放結束後放上一張影片最後一卡的蓋板圖片\nJavascript程式邏輯 var video_Element = document.querySelector(\u0026#34;#target-video\u0026#34;); //目標影片 var cover_img = document.querySelector(\u0026#34;#cover-img\u0026#34;); //蓋版圖片，預設display為none // 在影片上添加ended事件監聽偵測影片播放結束 video_Element.addEventListener(\u0026#39;ended\u0026#39;,function(){ cover_img.style.display = \u0026#39;block\u0026#39;; }); 之前曾在網路上看到有人寫說要不是有mac、iphone撐腰,不然Safari下場應該會跟IE差不多\u0026hellip;，一開始我還不以為意,但隨著經手的案子越來越多我開始慢慢認同這件事了\u0026hellip;\n不過雖然遇到這些坑真的很讓人煩躁，但是把這些坑填起來其實也有滿多幫助的,像是Page Visibility API除了用來填坑外還可以用來做效能上的優化,只能說事情有好有壞啦\n補充資料 Video play ended MDN\nPage Visibility API MDN\n","permalink":"https://bjmqfg83.github.io/blog/safari-render-issue/","tags":["程式學習"],"title":"Safari渲染問題"},{"categories":["javascript"],"contents":"最近公司接到一個案子,其中一個功能是當使用者進到網站時會自動播放一個滿版的影片,播放完後停在最後一卡不會重複播放，原本想說這應該穩穩的沒事,直到我遇到了那個萬惡的Safari\n當使用者進到頁面播放影片時,如果使用者使用行動裝置上的Safari播放影片的話,當使用者在影片播放「途中」讓手機待機會使影片直接停在待機前的狀態不會播放\n我們要讓safari在待機結束後可以繼續播放影片的話需要偵測手機是否待機,在待機時暫停播放、沒有在待機時繼續播放，雖然Javascript沒辦法偵測手機是否待機,但是Web APIs裡有提供一個可以做為替代方式的API\nPage Visibility API Page Visibility API會在網頁處於背景或是對於使用者來說看不到的情形下觸發,測試過手機待機時同樣有效，首先註冊 「visibilitychange」 的事件監聽,當使用者待機觸發事件時再透過 「document.hidden」 檢查畫面對於使用者來說是否被隱藏,為true時暫停播放、為false時繼續播放\nJavascript程式邏輯 var videoplay_state = false; var target_video = document.querySelector(\u0026#39;#target-video\u0026#39;); var hidden, visibilityChange; target_video.addEventListener(\u0026#39;ended\u0026#39;,function(){ videoplay_state = true; }); if (typeof document.hidden !== undefined) { // Opera 12.10 and Firefox 18 and later support hidden = \u0026#39;hidden\u0026#39;; visibilityChange = \u0026#39;visibilitychange\u0026#39;; } else if (typeof document.msHidden !== undefined) { hidden = \u0026#39;msHidden\u0026#39;; visibilityChange = \u0026#39;msvisibilitychange\u0026#39;; } else if (typeof document.webkitHidden !== undefined) { hidden = \u0026#39;webkitHidden\u0026#39;; visibilityChange = \u0026#39;webkitvisibilitychange\u0026#39;; } // If the page is hidden, pause the video 、 if the page is shown, play the video function handleVisibilityChange() { if(videoplay_state){ return; } if (!document.hidden) { target_video.play(); } else { target_video.pause(); } } if (typeof document.addEventListener === undefined || hidden === undefined) { alert(\u0026#39;This demo requires a browser, such as Google Chrome or Firefox, that supports the Page Visibility API.\u0026#39;); } else { document.addEventListener(\u0026#39;visibilitychange\u0026#39;, handleVisibilityChange, false); } 另外影片播放結束後待機也會有一個問題，當行動裝置上的Safari播放影片「結束」後再開啟會發現畫面整個是空白的，最快的解決方式是直接是在影片播放結束後放上一張影片最後一卡的蓋版圖片\nJavascript程式邏輯 var video_Element = document.querySelector(\u0026#34;#target-video\u0026#34;); //目標影片 var cover_img = document.querySelector(\u0026#34;#cover-img\u0026#34;); //蓋版圖片，預設display為none // 在影片上添加ended事件監聽偵測影片播放結束 video_Element.addEventListener(\u0026#39;ended\u0026#39;,function(){ cover_img.style.display = \u0026#39;block\u0026#39;; }); 之前曾在網路上看到有人寫說要不是有mac、iphone撐腰,不然Safari下場應該會跟IE差不多\u0026hellip;，一開始我還不以為意,但隨著經手的案子越來越多我開始慢慢認同這件事了\u0026hellip;\n不過我得說雖然遇到這些坑真的很讓人煩躁，但是把這些坑填起來其實也有滿多幫助的,像是Page Visibility API除了用來填坑外還可以用來做效能上的優化,只能說事情有好有壞啦\n補充資料 Video play ended MDN\nPage Visibility API MDN\n","permalink":"https://bjmqfg83.github.io/blog/videoissues/","tags":["程式學習"],"title":"厲害了我的Safari-Safari影片播放踩坑"},{"categories":["css"],"contents":"最近在專心看Vue3的東西所以疏於更新blog了 (其實是懶的\u0026hellip;) \u0026hellip;,想說在要寫Vue的文章之前先來寫點小東西練練手感,不然有點久沒寫部落格真的是會生疏。\nMotion Blur Motion blur又稱作動態模糊、運動模糊,主要是當相機拍攝一個快速移動的物體或是對拍攝物進行長時間的曝光所產生的模糊效果,那如果我們要讓網頁的元素做出物體移動時的模糊效果的話該怎麼做呢?\n我們可以透過CSS來達到類似的效果,將複數的元素包起來並設絕對定位讓元素堆疊起來並且給與元素不同的過渡或動畫延遲時間,這樣物體在移動時就會有那種好像因為動的很快所以產生殘引的感覺。\nMotionblurjs 如果不想要自己一個個新增物件的話可以使用MotionBlurJS提供的涵式庫來完成,只需要在元素上加上特定的class後自己定義CSS動畫即可\n\u0026lt;div id=\u0026#34;yourId\u0026#34; class=\u0026#34;blurjs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;yourId\u0026#34; class=\u0026#34;fadejs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 註 : Motionblurjs所做的事情也是新增元素並且給元素不同的delay時間\nMotionblurjs demo 參考資料: MotionBlurJS\nMotionBlur維基百科\nHow to Create a Realistic Motion Blur with CSS Transitions\n","permalink":"https://bjmqfg83.github.io/blog/motionblur/","tags":["css","程式學習"],"title":"移動時的殘影-CSS Motion Blur"},{"categories":["javascript"],"contents":"BOSS 弱點 【特定技術】先手為 O，後手為 X，某方獲勝時，上方會紀錄各方的獲勝戰績 【特定技術】每回合結束後，會判定結果頁(平手、Ｏ 獲勝、X 獲勝) 【特定技術】需符合 RWD，能在低螢幕解析度也能遊玩，介面不能超出 x 軸，至少在以下解析度能夠遊玩。 iPhone SE 320px iPhone 8 375px iPhone PLUS 414px 【特定技術】請使用瀏覽器離線儲存技術，將戰績保留起來，重新打開遊戲也仍可觀看到歷史戰績。技術請任選以下幾種 Cookie LocalStorage 【書寫能力】請寫 BLOG，描述你在開發「滿足獲勝條件」解題思維來進行加強描述 上面三個 O 符合獲勝條件 斜線三個 X 符合獲勝條件 請先不要參考網路上的寫法，試著用自身開發能力來解題，進以提升開發思維。但這段並非強制，真的卡關到爆炸，就還是試圖尋找攻略吧，但我相信想立志成為前端之碑的樓主，一定辦得到的！（崇拜眼神 程式邏輯 這次要細心一點的是RWD的縮放,程式邏輯的部分倒是還好,而程式邏輯有兩個地方要注意\n判斷當下是O或X的回合 判斷獲勝以及平手 由於一開始的設定是圈圈的回合而後是叉叉的回合反覆交替，以數學的概念來想圈圈是奇數回而叉叉是偶數回,所以我們程式可以這樣寫,透過counter的奇偶來判斷當前是屬於哪方的回合\nvar counter = 1; //一開始預設為1,圈圈的回合 var pos = e.target.dataset.pos; //綁在html上的自定義屬性,用於讓js添加class if (counter % 2 !== 0) { //圈圈的回合 if (!e.target.classList.contains(\u0026#34;circle\u0026#34;) \u0026amp;\u0026amp; !e.target.classList.contains(\u0026#34;cross\u0026#34;)) //已經下過就不能在同一位置下 { e.target.classList.add(\u0026#34;circle\u0026#34;); //添加圈圈樣式 document.querySelector(\u0026#34;.turn .circle-turn\u0026#34;).classList.add(\u0026#34;op-0\u0026#34;); //叉叉處顯示your turn document.querySelector(\u0026#34;.turn .cross-turn\u0026#34;).classList.remove(\u0026#34;op-0\u0026#34;); //圈圈處your turn隱藏 counter += 1; // +1表示下回合換叉叉下 } } else { //叉叉的回合 if (!e.target.classList.contains(\u0026#34;circle\u0026#34;) \u0026amp;\u0026amp; !e.target.classList.contains(\u0026#34;cross\u0026#34;)) { e.target.classList.add(\u0026#34;cross\u0026#34;); document.querySelector(\u0026#34;.turn .circle-turn\u0026#34;).classList.remove(\u0026#34;op-0\u0026#34;); document.querySelector(\u0026#34;.turn .cross-turn\u0026#34;).classList.add(\u0026#34;op-0\u0026#34;); counter += 1; } } 只要圈或叉可以連成一條線都算獲勝,總共有8種獲勝的條件\n分成三個圖比較方便看\nvar status = [null,null,null,null,null,null,null,null,null]; //用來判斷9個位置是否都已下完 true為circle false為cross function judge() { var result = null; // circle win if (status[0] === true \u0026amp;\u0026amp; status[1] === true \u0026amp;\u0026amp; status[2] === true) { result = true; } else if (status[3] === true \u0026amp;\u0026amp; status[4] === true \u0026amp;\u0026amp; status[5] === true) { result = true; } else if (status[6] === true \u0026amp;\u0026amp; status[7] === true \u0026amp;\u0026amp; status[8] === true) { result = true; } else if (status[0] === true \u0026amp;\u0026amp; status[4] === true \u0026amp;\u0026amp; status[8] === true) { result = true; } else if (status[2] === true \u0026amp;\u0026amp; status[4] === true \u0026amp;\u0026amp; status[6] === true) { result = true; } else if (status[1] === true \u0026amp;\u0026amp; status[4] === true \u0026amp;\u0026amp; status[7] === true) { result = true; } else if (status[0] === true \u0026amp;\u0026amp; status[3] === true \u0026amp;\u0026amp; status[6] === true) { result = true; } else if (status[2] === true \u0026amp;\u0026amp; status[5] === true \u0026amp;\u0026amp; status[8] === true) { result = true; } // cross win if (status[0] === false \u0026amp;\u0026amp; status[1] === false \u0026amp;\u0026amp; status[2] === false) { result = false; } else if (status[3] === false \u0026amp;\u0026amp; status[4] === false \u0026amp;\u0026amp; status[5] === false) { result = false; } else if (status[6] === false \u0026amp;\u0026amp; status[7] === false \u0026amp;\u0026amp; status[8] === false) { result = false; } else if (status[0] === false \u0026amp;\u0026amp; status[4] === false \u0026amp;\u0026amp; status[8] === false) { result = false; } else if (status[2] === false \u0026amp;\u0026amp; status[4] === false \u0026amp;\u0026amp; status[6] === false) { result = false; } else if (status[1] === false \u0026amp;\u0026amp; status[4] === false \u0026amp;\u0026amp; status[7] === false) { result = false; } else if (status[0] === false \u0026amp;\u0026amp; status[3] === false \u0026amp;\u0026amp; status[6] === false) { result = false; } else if (status[2] === false \u0026amp;\u0026amp; status[5] === false \u0026amp;\u0026amp; status[8] === false) { result = false; } if (result === true) { // circle win } else if (result === false) { // cross win } // 判斷9個空格是否都已佔用且result不是true也不是false為平手 if (this.counter - 1 === 9 \u0026amp;\u0026amp; result !== true \u0026amp;\u0026amp; result !== false) { // draw平手 } } vw、vh、vmax、vmin 我使用了vw來做網頁畫面的縮放,一個主要原因是這樣其實滿方便的 (雖然要一直拿計算機計算) ,另一個原因是做過一些活動跟產品介紹頁面,那些頁面的設計一定要用隨螢幕縮放的方式來做不然會有問題\u0026hellip;\nvw view width 抓取螢幕可視範圍寬度的百分比,比如說15vw指的是百分之15的螢幕可視範圍寬度\nvh view height 抓取螢幕可視範圍高度的百分比,比如說15vh指的是百分之15的螢幕可視範圍高度\nvmax vmax 抓取長度或寬度較大的百分比,如果是pc螢幕抓取的就可能是寬度的百分比而mb抓取的可能就是高度的百分比\nvmin vmin 抓取長度或寬度較小的百分比,如果是pc螢幕抓取的就可能是高度的百分比而mb抓取的可能就是寬度的百分比\ncookie vs localStorage vs sessionStorage cookie\nHttp協定是無狀態的，也就是說server端不會知道client端上一次做什麼，而cookie就是避開Http無狀態的手段之一，server可以設定或讀取cookies的資訊，藉此來維護client端跟server端對談中的狀態，另外當一個cookie沒有設定失效時間,會在使用者關閉瀏覽器後被自動刪除。\ndocument.cookie // 讀取cookie document.cookie = \u0026#34;key1=value1;\u0026#34;; //設定cookie 本來想說這次使用cookie來儲存資料並設定cookie過期的時間,不過vue存cookie貌似有問題，之後再找時間研究一下\u0026hellip;\nlocalStorage、sessionStorage\nlocalStorage、sessionStorage我直接把之前寫的文章內容複製貼上\u0026hellip;\nlocalStorage以及sessionStorage為客戶端的資料儲存技術容量大小都為5MB,透過設定key:value的方式來儲存資料進瀏覽器，跟cookie不同的是在與server溝通時不會被自動帶入\nlocalStorage以及sessionStorage兩者之間唯一的不同就是localStorage如果使用者不刪除資料該筆資料會永遠存在在瀏覽器內但sessionStorage只要該分頁關閉時資料就會清除掉\n// localStorage localStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); // 設定localStorage localStorage.getItem(\u0026#39;myName\u0026#39;); // 取得localStorage localStorage.removeItem(\u0026#39;myName\u0026#39;); // 移除localStorage localStorage.clear(); //清除localStorage // sessionStorage sessionStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); // 設定sessionStorage sessionStorage.getItem(\u0026#39;myName\u0026#39;); // 取得sessionStorage sessionStorage.removeItem(\u0026#39;myName\u0026#39;); // 移除sessionStorage sessionStorage.clear(); //清除sessionStorage 8F井字遊戲 demo連結 剩下一半了\u0026hellip;希望我身體還頂得住\n補充資料 好用的css 3新單位vh vw\nlocalStorage\nsessionStorage\ncookie wikipedia\ncookie MDN\n[WEB] Cookie \u0026amp; Session 是什麼？\nJavaScript Cookie\n","permalink":"https://bjmqfg83.github.io/blog/tictactoe/","tags":["程式學習"],"title":"Tic Tac Toe 井字遊戲-六角學院Javascript新手地下城"},{"categories":["javascript"],"contents":"這座山終於快爬完一半了\u0026hellip;不得不說如果真的不知道該怎麼做時參考網路上類似的範例是一個還不錯的選擇,不然你可能卡在路上半天還在迷路\u0026hellip;\nPhoto by pixabay\nBOSS 弱點 【特定技術】遊戲規則\n繪圖區請使用 Canvas 來設計，上方的控制列與下方的畫筆調整可不用 SAVE ：點擊後可直接下載轉出的 PNG 圖片 CLEAR ALL：清除畫版樣式 UNDO、REDO：上一步、下一步 點擊箭頭時，功能列介面皆可進行收闔 【擴充功能】請再自行增加「兩個功能」，我相信勇者們都是很有梗的~ Canvas DOM vs Canvas\nDOM在繪製主要是透過瀏覽器的graphic api來做,因為實際的細節是由瀏覽器處理所以操作上較為簡單,但是DOM的操作是很耗內存的,DOM越多內存的消耗量越大,而canvas雖然操作上較為困難但是速度快且善於處理大量的元素\n要使用時在html內加上canvas,之後js透過id做canvas的相關設定\nHTML\n\u0026lt;canvas id=\u0026#34;canvas-panel\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; Javascript\n// 基礎設定 function canvas_setting() { //獲取2d畫筆物件 if (this.canvas.getContext) { this.canvas.width = window.innerWidth; //設定canvas寬度為畫面寬度 this.canvas.height = window.innerHeight; //設定canvas高度為畫面高度 this.ctx = this.canvas.getContext(\u0026#34;2d\u0026#34;); //獲取canvas 2d畫筆 this.ctx.lineWidth = this.line_width; //設定線條粗細 this.ctx.strokeStyle = this.pen_color; //設定線條顏色 } else { alert(\u0026#34;Browser not support canvas\u0026#34;); } } //繪畫設定 function drawImg(x1, y1, x2, y2) {//畫圖時需要畫筆以及兩點的x,y座標 //設定線條的端點如何繪製,round為端點帶有一個半圓形的線蓋 if (this.ctx.lineCap !== \u0026#34;round\u0026#34;) { this.ctx.lineCap = \u0026#34;round\u0026#34;; } // 設定線條與線條之間如何連結,round為圓弧形連接 if (this.ctx.lineJoin !== \u0026#34;round\u0026#34;) { this.ctx.lineJoin = \u0026#34;round\u0026#34;; } this.ctx.beginPath(); //開始繪製 this.ctx.moveTo(x1, y1); //設定開始位置 this.ctx.lineTo(x2, y2); //設定移動位置 this.ctx.closePath(); //關閉路徑 this.ctx.stroke(); //路徑上色 } Mouse Event Mouse Event是完成畫板基本繪畫功能的一個非常重要的事件,要完成基本繪畫功能需要下列三個事件監聽\nmousedown - 滑鼠壓下 mousemove - 滑鼠移動 mouseup - 滑鼠放開 this.canvas.addEventListener(\u0026#34;mousedown\u0026#34;, (e) =\u0026gt; { //buttons為1表示為按下的滑鼠按鍵為左鍵-不讓其他鍵觸發事件 if (e.buttons === 1) { this.pos_x = e.clientX; //抓取滑鼠水平位置 this.pos_y = e.clientY; //抓取滑鼠垂直位置 this.drawing = true; } }); this.canvas.addEventListener(\u0026#34;mousemove\u0026#34;, (e) =\u0026gt; { // 要畫成線需要兩組x、y座標 this.drawImg(this.pos_x,this.pos_y,e.clientX,e.clientY); this.pos_x = e.clientX; this.pos_y = e.clientY; }); // 滑鼠移開時畫筆位置重置,drawing狀態為false this.canvas.addEventListener(\u0026#34;mouseup\u0026#34;, (e) =\u0026gt; { // 避免繪畫時有放開其他滑鼠按鍵的狀況 if (e.buttons !== 1) { this.pos_x = 0; //抓取滑鼠水平位置歸0 this.pos_y = 0; //抓取滑鼠垂直位置歸0 this.drawing = false; //儲存當前的狀態方便用於上一步、下一步 this.step += 1; //歷史紀錄步驟+1 this.record_Arr.push(this.canvas.toDataURL()); //將資料存成base64編碼後放進陣列,之後上一步、下一步會用到 } }); Data URI Data URI在網頁上的作用就是透過將圖片轉換為文字編碼的方式直接儲存在HTML、CSS內來降低Http請求次數(一張圖片就是一個請求)進而增進網頁載入效能的一個方式，但是同時他也有著無法快取、可讀性差、檔案變大(大約33%)以及如果圖檔有變化時需要重新編碼的缺點,所以要使用的話還是要依照當下狀況來看\u0026hellip;,在這一題裡Data URI是用作「下載圖片」以及繪畫時的「上一步、下一步」用\nData URI格式\ndata:[\u0026lt;mediatype\u0026gt;][;base64],\u0026lt;data\u0026gt; 我們可以透過canvas內建的toDataURL將其轉換成Data URI後下載\ncanvas.toDataURL(type, encoderOptions); // type為類型 ex: image/png(默認)、image/jpeg、image/webp... // encoderOptions為圖片品質範圍為0~1,指定圖片格式為image/jpeg 或 image/webp 程式碼\n// 下載圖片 function downloadImg() { const dataUrl = this.canvas.toDataURL(\u0026#34;image/png\u0026#34;); document.querySelector(\u0026#34;.save\u0026#34;).href = dataUrl; //轉換完後丟給a標籤,之後只要點擊標籤就會下載 } // 不論是上一步、下一步都需要先等待圖片載入完畢 // 上一步 function undo(){ if (this.step \u0026gt; 0) { //先將狀態回到上一步 var last_history = new Image(); var window_width = window.innerWidth; var window_height = window.innerHeight; last_history.src = this.record_Arr[this.step-1]; //載入上一筆歷史紀錄 last_history.onload = () =\u0026gt; { this.ctx.clearRect(0, 0, window_width, window_height); //繪圖前必須先清除畫布 this.ctx.drawImage(last_history, 0, 0); //載入圖片 this.step-=1; //歷史紀錄步驟-1 }; } } // 下一步 function redo_canvas() { // 如果有上一步操作才可以下一步 if (this.step \u0026lt; this.record_Arr.length) { var last_history = new Image(); var window_width = window.innerWidth; var window_height = window.innerHeight; last_history.src = this.record_Arr[this.step + 1]; //載入下一筆歷史紀錄 last_history.onload = () =\u0026gt; { this.ctx.clearRect(0, 0, window_width, window_height); //繪圖前必須先清除畫布 this.ctx.drawImage(last_history, 0, 0); //載入圖片 this.step +=1 ; //歷史紀錄步驟+1 }; } } 客製化功能 這次客製化了「顏色選取器」以及「橡皮擦」這兩個功能,我們直接來看程式碼\n顏色選取器\n//選取色盤的顏色並變換畫筆顏色 function color_picker() { var color_picker = document.getElementById(\u0026#34;color-panel\u0026#34;); //抓取type為color的input color_picker.addEventListener(\u0026#34;input\u0026#34;, (e)=\u0026gt; { this.selected_color = e.target.value; //抓取選取到的顏色 document.querySelector(\u0026#39;.colors .show\u0026#39;).parentElement.style.backgroundColor = this.selected_color; //將原先勾選到的顏色改成目前選取的顏色 this.pen_color = this.selected_color; //改變畫筆顏色 this.ctx.strokeStyle = this.pen_color; //改變畫筆顏色 }); } 橡皮擦\n橡皮擦原先的想法是想說將畫筆的顏色直接改成跟背景顏色一樣就可以了,但是png檔的背景是透明的,所以輸出的圖片會變成這樣 (灰色的部分為橡皮擦擦過的路徑)\n所以單純改變畫筆顏色是不行的,但是我們可以透過canvas的clearRect來將滑鼠滑過的區域清除掉\nthis.ctx.clearRect(x,y,width,height); //x、y為座標 width、height為清除的寬與高 這樣橡皮擦的功能就完成了,詳細的狀況可以去看我寫的code\u0026hellip;\n額外補充 canvas需要透過直接寫在HTML或是透過JS去設定寬高且無法透過CSS設定,在這樣的情況下如果要讓canvas的寬高隨螢幕resize時我們直覺會直接註冊一個resize的事件監聽，但是直接更改canvas的寬跟高會導致畫布被清空的bug\u0026hellip;，想要解決這樣的問題我們可以透過undo、redo有用到的歷史紀錄，在螢幕resize時載入最新的一筆歷史紀錄,這樣即便在resize後畫布上的圖依然還會存在\nwindow.addEventListener(\u0026#34;resize\u0026#34;, () =\u0026gt; { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; //先將狀態回到上一步 var last_history = new Image(); var window_width = window.innerWidth; var window_height = window.innerHeight; last_history.src = this.record_Arr[this.step]; last_history.onload = () =\u0026gt; { this.ctx.clearRect(0, 0, window_width, window_height); this.ctx.drawImage(last_history, 0, 0); }; }); 7F畫板 demo連結 最近對於時間管理真的非常有感觸，有很多應該做以及想做的事情像是刷題目、寫文章、進修程式、運動、看課外書、交女朋友\u0026hellip;，這些全部都要花時間,懂得如何利用零碎的時間並增進做事效率真的很重要，希望有朝一日我也能夠成為一位專業的時間管理大師\u0026hellip;\nPhoto by pixabay\n補充資料 Canvas API MDN\nDOM vs Canvas\nInput Color MDN\nMousedown MDN\nMouse Event 小筆記\n使用 DATA URI 將圖片以 Base64 編碼並內崁至網頁中，加速載入速度\n","permalink":"https://bjmqfg83.github.io/blog/drawing_board/","tags":["程式學習"],"title":"畫板drawing board-六角學院Javascript新手地下城"},{"categories":["javascript"],"contents":"遊戲規則 0~20 秒為 1位數計算 (5-3)，21~40 秒為 2 位數計算 (30*19)，41~60 秒為 3 位數計算 (332+312)，加減乘除規則請用隨機產生，不可寫死題目，60 秒內可無限次數答題。 0~40 秒答對加一分，41~60 秒答對加五分，答錯扣一分，最多僅能扣到零分 【特定技術】不可設計跳轉頁面，都得在同一頁內部切換頁面完成。 使用技術 JS : Vue、if else、Math、switch、localStorage、setInterval\nCSS: SCSS(CSS前處理語言)、flex、Input Number customize\nOthers: google fonts\n開發歷程 使用Vue做開發(我就懶)，讓vue做畫面渲染並使開發過程專注在程式邏輯上 時間上透過setInterval去執行60秒的倒數,時間倒數到0時清除週期性定時器Interval並跳至最後一個頁面，當使用者在最後的頁面點擊try again時重新開始遊戲 使用Math.random亂數產生題目，使用者送出答案時除了對答案還會依據目前所剩時間給予相對應的分數並依所剩時間產生相對應難度的題目 新增小功能為透過localStorage去儲存自己遊戲的最高分,這是純前端的作法，如果有跟後端配合的話可以延伸至分數排行榜等等\u0026hellip; Input Number customize 我們要讓使用者輸入數字時會使用 **\u0026lt;input type=\u0026ldquo;number\u0026rdquo;\u0026gt;**這個HTML表單元件,這個元件會有預設的上下箭頭讓使用者去調整數字,但是元件的上下箭頭個人認為跟整體設計非常不搭所以移除掉，現在來看一下CSS語法吧\ninput[type=\u0026#34;number\u0026#34;] { width: 255px; height: 131px; outline: none; font-size: 112px; font-weight: bold; text-align: center; border: none; /* default style firefox */ -moz-appearance: textfield; /* default style safari、chrome、ie */ \u0026amp;::-webkit-inner-spin-button,\u0026amp;::-webkit-outer-spin-button { appearance: none; -webkit-appearance: none; margin: 0; } } 註:在客製化樣式方面發現firefox很常需要下跟其他瀏覽器不同的前綴字，想客製化元件樣式的時候要注意一下\nlocalStorage、sessionStorage localStorage以及sessionStorage為客戶端的資料儲存技術容量大小都為5MB,透過設定key:value的方式來儲存資料進瀏覽器，跟cookie不同的是在與server溝通時不會被自動帶入\nlocalStorage以及sessionStorage兩者之間唯一的不同就是localStorage如果使用者不刪除資料該筆資料會永遠存在在瀏覽器內但sessionStorage只要該分頁關閉時資料就會清除掉\n// localStorage localStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); localStorage.getItem(\u0026#39;myName\u0026#39;); localStorage.removeItem(\u0026#39;myName\u0026#39;); localStorage.clear(); // sessionStorage sessionStorage.setItem(\u0026#39;myName\u0026#39;, \u0026#39;Tom\u0026#39;); sessionStorage.getItem(\u0026#39;myName\u0026#39;); sessionStorage.removeItem(\u0026#39;myName\u0026#39;); sessionStorage.clear(); 透過localStorage去儲存玩家遊戲的分數，如果當次分數比上次高就會儲存進去\n安全性 當我們要使用Vue時大多習慣這樣寫\nconst app = new Vue({...}); 但這樣使用者其實可以打開瀏覽器的console端去把分數改掉\n可以把const app移除掉讓使用者沒辦法透過console端去修改資料\n但是這樣還不夠，使用者可以透過瀏覽器去修改localStorage的值去更改最高紀錄的分數\n這時候我們可以新增一個storage的事件監聽,只要在遊戲進行時偵測到localStorage的值被修改就將分數歸0並重新開始遊戲，只有在遊戲結束時分數要進行更新時允許更新localStorage,更新完後一樣禁止再次修改localStorage的值\nfunction security(){ window.addEventListener(\u0026#39;storage\u0026#39;,()=\u0026gt;{ if(this.higest !== localStorage.getItem(\u0026#34;higestscore\u0026#34;)){ alert(\u0026#34;偵測到分數被修改，遊戲積分歸0\u0026#34;); localStorage.setItem(\u0026#34;higestscore\u0026#34;,0); // history.go(0); this.try_again(); } }); } 因為程式內部的賦值也是更新,所以遊戲結束要賦值前記得先將事件監聽移除，等到程式內部的更新完成後再重新註冊一次事件監聽\nwindow.removeEventListener(\u0026#39;storage\u0026#39;); 我個人是透過修改資料內的狀態來重新開始遊戲,不過可能會有人想透過history.go(0)或是window.reload()等方式重新開始遊戲，但是這在codepen會有問題,建議要試的可以將自己的檔案下載下來後再測試\ncodepen針對reload頁面的說明我放在參考資料內\nDemo 連結 參考資料: Input Number 客製化\nWeb Storage MDN\nlocalStorage MDN\nsessionStorage MDN\nreferred-from-pen-message\n","permalink":"https://bjmqfg83.github.io/blog/mathgame/","tags":["javascript","程式學習"],"title":"60秒算數遊戲-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : Vue、axios、For迴圈、Regular expressions、Array\nCSS: SCSS(CSS前處理語言)、flex、customize scrollbar\nOthers: google fonts、政府資料開放平台-空氣品質指標(AQI)\n開發歷程 想要專注在邏輯上所以使用框架開發,當資料更新時由Vue負責畫面渲染\n資料的取得使用axios這個套件串接政府資料開放平台的API，另外頁面的部分做了一個假的selection方便客製化CSS樣式，其餘js程式邏輯使用forEach過濾出符合條件的資料、正規表示法調整更新時間顯示的格式\nXMLHttpRequest 在提交表單資料、串接API這種非同步行為時會希望過程中仍可以對網頁進行操作及瀏覽\n這時候我們可以透過XMLHttpRequest讓網頁在進行非同步的操作時不會卡住或是重整\n//Step 1 創建異步物件 var xhr = new XMLHttpRequest(); //可以簡稱xhr物件 //Step 2 創建異步請求 // method為http請求(get、post...)、url為請求路徑、async為為非同步設定,true為非同步、false為同步 xhr.open(method, url, async); //3.設定監聽事件 // 當xhr物件接受到server的嚮應且響應狀態為200(ok)時進行後續處理 xhr.onreadystatechange = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // 取得響應的訊息 var resText = xhr.responseText; } } // 4.送出請求，send參數除post以外都給null xhr.send(null); 如果是post請求的話需要額外設定RequestHeader，告知server要提交的資料類型並把資料放置send提交\n// 以表單資料為例 xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); var msg = \u0026#39;data1=\u0026#39; + 資料1 +\u0026#39;\u0026amp;\u0026#39;+ \u0026#39;data2\u0026#39; + 資料2... ; xhr.send(msg); 註: 雖然是叫「XML」HttpRequest但也可以使用純文字或是JSON格式的資料\nPromise 在簡單的專案可能還沒關係，但如果專案的需求須要進行多個請求或是要在請求後進行很多程式的處理的話可能會變成下面這樣\n圖片來源: Node 7.6 + Koa 2: asynchronous flow control made right\n這種波動拳的樣子有個別稱叫「Callback hell 回調地獄」，這會造成日後程式維護、擴充上的不便，我們可以透過ES6的Promise來改善,這邊簡單概述一下\nPromise有以下三種狀態\n擱置(pending)：初始狀態，表示操作進行中 實現(fulfilled) ：表示操作成功，執行resolve(),可透過then查看結果 拒絕(rejected)： 表示操作失敗，執行reject(),可透過catch查看結果 圖片來源: Promise MDN\nfunction PromiseFn() { return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); // 可以把api_key後面的參數改掉刻意引發CORS的錯誤來執行reject xhr.open(\u0026#34;get\u0026#34;,\u0026#34;https://data.epa.gov.tw/api/v1/aqx_p_432?limit=1000\u0026amp;api_key=9be7b239-557b-4c10-9775-78cadfc555e9\u0026amp;format=json\u0026#34;); // xhr.onreadystatechange可用onload取代 xhr.onload = function() { resolve(JSON.parse(xhr.responseText)); } xhr.onerror = function(){ reject(xhr); } xhr.send(null); }); } PromiseFn() .then(function(res){ ... return PromiseFn(); }).then(function(res2){ ... return PromiseFn(); }).then(function(res3){ ... }).catch(function(error){ ... }); 這樣就避免了波動拳的產生，後續要繼續進行非同步操作時透過return一個Promise的方式進續進行\nPromise還有其他如Promise.all()、Promise.race()等等的方法\u0026hellip;甚至在ES7版本有更好用的Async/Await可以用同步的思維去做非同步的操作，有興趣的朋友可以研究看看\nFetch API 以前如果想要簡化XMLHttpRequest的寫法通常都會使用jQuery的ajax來做，現在在HTML5的標準內我們有原生的Fetch API可以使用\nFetch API有幾點特性\n使用Promise做回應 使用then做下一步處理、catch作錯誤處理 一開始的回傳為ReadableStream，需要針對不同的資料類型使用對應方法獲取資料ex:json()、text()、blob()\u0026hellip; 只要server有響應不論status code是404或是500Promise的狀態都會是fulfilled而不是rejected，這部分需要額外做處理 現在看一下程式碼\nfetch(\u0026#39;https://jsonplaceholder.typicode.com/todos/1\u0026#39;) .then(res =\u0026gt; { console.log(res); // response的body內可以看到ReadableStream if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳 }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }) .then(json =\u0026gt; console.log(json)) .catch(err =\u0026gt; { console.error(\u0026#39;錯誤\u0026#39;, err); }); POST方法一樣要設定header跟body\nfetch(url, { method: \u0026#39;POST\u0026#39;, // headers 加入 json 格式 headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, // body 將 json 轉字串送出 body: JSON.stringify({ data_A: \u0026#39;xxxx\u0026#39;, data_B: \u0026#39;xxxx\u0026#39; }).then(res =\u0026gt;{ if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳 }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }).then(jsonData =\u0026gt; {console.log(jsonData)}; ).catch(err =\u0026gt; { console.log(\u0026#39;錯誤:\u0026#39;, err); }) CORS CORS全稱為Cross-Origin Resource Sharing 跨來源資源共享，瀏覽器基於安全性的考量會限制使用者存取其他來源的資源\n以下幾種情況會被當作不同來源\n不同協定 ex: \u0026quot;https\u0026quot;、\u0026quot;http\u0026quot; 不同domain ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example_others.com\u0026quot; 不同port ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example.com:8080\u0026quot; 跟後端協作串接API時如果遇到CORS通常後端會去設定Access-Control-Allow-Origin來讓特定來源能夠存取資源或是乾脆使用*號(通配符)讓所有不同來源都能夠存取\n但如果要串接的是第三方的API的話可以參考一下六角助教寫的Google Apps Script這篇文章去試看看，大概的理解是CORS是因為瀏覽器請求非同源的資源所發生，那就不用瀏覽器去請求來規避這個問題\n我用新竹縣政府公務人員參訓人數這個API去試了之後沒問題，但是對於像是需要API_KEY金鑰的API如空氣品質指標(AQI)一樣還是會有CORS的問題發生，所以Google Apps Script只是一個暫時性的方式，實作上還是要因應情況去做調整\nAQI Demo連結 參考資料: ReadyState MDN\nPromise MDN\nFetch MDN\nOxxO STUDIO Fetch API 使用教學\n","permalink":"https://bjmqfg83.github.io/blog/air_quality/","tags":["javascript","程式學習"],"title":"全台空氣指標儀表板-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : For迴圈、Date、string、setInterval\nCSS: SCSS(CSS前處理語言)、Grid Layout\nOthers: google fonts\n開發歷程 這次的切版跟程式邏輯都不算複雜,麻煩的是要找Date().toLocaleString的參數設定,有需要的可以看看參考資料的連結，現在這邊來跟各位分享相關知識\n時間戳timestamp timestamp指的是從1970年1月1日0時0分0秒開始到現在總共經過多少豪秒數，可用於追蹤時間、計算時間差、日期排序等等\u0026hellip;，在js內可透過new Date().getTime()取得，不過在查詢資料的時候看到有人說是經過的「秒數」，但使用相關函式獲取到的到底是毫秒還是秒這部分可能跟程式語言、系統環境有關，javascript獲取到的是「毫秒數」、php獲取到的是「秒數」，有興趣的可以到epochconverter、unixtimestamp看看\nGMT、UTC GMT全稱為格林威治標準時間(Greenwich Mean Time)、UTC全稱為世界協調時間(Coordinated Universal Time),台灣所在的時區快八小時所以可以表示成「GMT+8」或是「UTC+8」，那至於GMT、UTC的差別詳細的可以參考泛科學的到底是 GMT+8 還是 UTC+8 ?，日常生活中兩者沒什麼區別可以混用,只是由於地球自轉速度在變慢導致GMT的1秒越來越長，UTC會在超過GMT快1秒時加入「閏秒」來抵消超前的量\nworld clock時區 要獲取指定地區的日期時間我們可使用Date物件的toLocaleString\nnew Date().toLocaleString([locales[, options]]) locales為語言環境，簡單來說是讓時間以該語言的格式顯示，比如說你locales給'zh-tw(台灣)'的話顯示的格式為\u0026quot;2021/2/10 下午1:42:31\u0026quot;，如果給'en-GB(英國)'的話顯示的格式為\u0026quot;10/02/2021, 13:48:17\u0026quot;，但這只是顯示的格式而已,時區還是在使用者所在的地區,如果要顯示別的時區的時間需要透過options做設定\noptions可以設定時區以及年、月、日等等的顯示格式，這邊列出有使用到的\ntimeZone =\u0026gt; 設定要顯示的地區時間 hour12 =\u0026gt; 設定顯示是否為12小時制 year =\u0026gt; 設定顯示年分格式 month =\u0026gt; 設定顯示月份格式,可為英文或數字 day =\u0026gt; 設定顯示日期格式 hour =\u0026gt; 設定顯示小時格式 minute =\u0026gt; 設定顯示分鐘格式 注: locales、options內詳細的參數設定可以直接看最後面的參考資料\nJS程式邏輯 // 時區依序為美國、英國倫敦、曼谷、台北、澳洲雪梨 const timeZones = [ \u0026#34;America/New_York\u0026#34;, \u0026#34;Europe/London\u0026#34;, \u0026#34;Asia/Bangkok\u0026#34;, \u0026#34;Asia/Taipei\u0026#34;, \u0026#34;Australia/Sydney\u0026#34; ]; // toLocaleString options參數 const options = { timeZone: \u0026#34;Asia/Taipei\u0026#34;, // 時區設定台北 hour12: false, //不以12小時制顯示,會以24小時制顯示 year: \u0026#34;numeric\u0026#34;, //正常數字顯示 month: \u0026#34;short\u0026#34;, //short只會顯示三位英文 ex: February =\u0026gt; Feb day: \u0026#34;2-digit\u0026#34;, //顯示兩位 ex: 1 =\u0026gt; 01 hour: \u0026#34;2-digit\u0026#34;, //顯示兩位 minute: \u0026#34;2-digit\u0026#34; //顯示兩位 }; function world_clock() { timeZones.forEach((item, index) =\u0026gt; { var temp_clockInfo = \u0026#34;\u0026#34;; var temp_dateInfo = \u0026#34;\u0026#34;; options.timeZone = item; // 時區使用英國(en-GB)顯示結果就會是日、月、年、時間 temp_clockInfo = new Date().toLocaleString(\u0026#34;en-GB\u0026#34;, options); //月份後面添加「. 」後重新拼接日期字串 temp_dateInfo = temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[0] + \u0026#34; \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[1] + \u0026#34;. \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[2]; //更新年月日的元素 document.querySelectorAll(\u0026#34;.location-info .location-date\u0026#34;)[index].innerText = temp_dateInfo; //依格式中的「,」分割出時分後更新DOM,透過index下標去找目標元素 document.querySelectorAll(\u0026#34;.location-info \u0026gt; div:nth-of-type(2)\u0026#34;)[index].innerText = temp_clockInfo.split(\u0026#34;,\u0026#34;)[1].trim(); }); } world_clock(); // 每秒鐘調用一次判斷getSeconds()是否為59，為59示1分鐘要到可以調用函數更新時間 var clock_timer = setInterval(function(){ if(new Date().getSeconds()===59){ world_clock(); } },1000); world clock codepen連結 參考資料: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nhttps://blog.techbridge.cc/2020/12/26/javascript-date-time-and-timezone/\n","permalink":"https://bjmqfg83.github.io/blog/world_clock/","tags":["javascript","程式學習"],"title":"WORLD CLOCK-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : Vue、正規表達式、String(substring、replace、split)、For迴圈、Array(reverse)\nCSS: SCSS(CSS前處理語言)、Customize Scrollbar\n開發歷程 這次寫題目時想順便複習FrameWork所以使用了Vue做開發，花了滿多時間想怎麼在千分位前加上「,」以及避免計算結果出現「undefined」、「NAN」\n千分位資料處理 整數位數超過三位時要加上千分位符「,」需要使用正規表達式、字串、陣列的方法來處理\n//當計算機輸入到加、減、乘、除時對運算符前的數字做千分位符的處理 // +號在正規表達式有特定意思所以要單純匹配需在前面加上「反斜線」 // g表示要找出所有符合條件的結果，不加的話只會找出第一筆符合條件的結果就結束 const comma_rule = /(\\+|-|×|÷)/g; let prev_comma = \u0026#34;\u0026#34;; //整數位 let after_comma = \u0026#34;\u0026#34;; //小數位 let comma_val = \u0026#34;\u0026#34;; //加上千分位的結果 function compute_comma(){ comma_arr = result.split(comma_rule); //依據規則分隔出符合條件的陣列資料 comma_arr.forEach((item, index) =\u0026gt; { if (!isNaN(parseFloat(item))) { // 判斷是否為加、減、乘、除,只處理非NAN的資料 prev_comma = (item.split(\u0026#34;.\u0026#34;)[0] || \u0026#34;\u0026#34;).split(\u0026#34;\u0026#34;).reverse(); //整數位轉成陣列處理 after_comma = item.split(\u0026#34;.\u0026#34;)[1] || \u0026#34;\u0026#34;; //小數點先暫存進變數等處理完整數之後再整合進去 comma_val = \u0026#34;\u0026#34;; //每次迴圈前先清空 //前面的reverse()用來方便拼接字串 //ex:[3,8,5,6].reverse() =\u0026gt; [6,5,8,3] for (let i = 0; i \u0026lt; prev_comma.length; i++) { //當到第四位時在第三位前加上千分位符「,」 if (i % 3 === 0 \u0026amp;\u0026amp; i !== 0) { // step 4 =\u0026gt; \u0026#34;3\u0026#34;+\u0026#34;,\u0026#34;+\u0026#34;856\u0026#34; comma_val = prev_comma[i] + \u0026#34;,\u0026#34; + comma_val; //非第四位則單純拼接 } else { // step 1 =\u0026gt; \u0026#34;6\u0026#34;+ \u0026#34;\u0026#34;、step 2 =\u0026gt; \u0026#34;5\u0026#34; + \u0026#34;6\u0026#34;、step 3 =\u0026gt; \u0026#34;8\u0026#34; + \u0026#34;56\u0026#34; comma_val = prev_comma[i] + comma_val; } } } }); } 其餘的輸入規則如避免「NAN」、「undefined」讀者可以稍微思考一下如何處理，這邊就不贅述\nScrollbar客製化 稍微看過其他人做的計算機在位數過多時滿多都是使用js調整字體大小來避免畫面破格,但我個人不太想要調整字體大小所以選擇用css處理位數過多的問題，在畫面位數過多時會出現scrollbar可以滑動，可能會有人覺得瀏覽器預設的不是很好看，這部分可以透過css去調整\n注:scrollbar的調整Firefox要額外寫\nFirefox scrollbar-width: auto | thin | none | 1em | inherit | initial | unset ; scrollbar-color: auto | dark | light | color1(滾動條本身的顏色thumb) color2(滾動條外容器的顏色track); 注: color1、color2可以用關鍵字(red、blue\u0026hellip;)或是色碼\nChrome、IE Edge、Safari /* 屬性前要加::-webkit-前綴字 */ ::-webkit-scrollbar: width | height ; ::-webkit-scrollbar-thumb: background | box-shadow | ... ; 注: 這邊簡單列出有使用到的，有需要的話可參考底下連結\n計算機 codepen連結 參考資料: https://css-tricks.com/custom-scrollbars-in-webkit/\nhttps://css-tricks.com/examples/WebKitScrollbars/\nhttps://stackoverflow.com/questions/6165472/custom-css-scrollbar-for-firefox/53739309#53739309\nhttps://github.com/Aris-t2/CustomCSSforFx/issues/160\n","permalink":"https://bjmqfg83.github.io/blog/hex_calculator/","tags":["javascript","程式學習"],"title":"計算機Calculator-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術: JS : Const變數、Date物件、SetInterval、Template literals樣板字串\nCSS: SCSS(CSS前處理語言)、clip-path\n開發歷程: JS的部分透過Date物件獲取當前的時間、setInterval更新時間並且在內部判斷指針的轉動、Template literals用於方便將計算指出來的旋轉角度整合進字串內\nCSS的部分使用SCSS變數去存取顏色、mixin存取會大量使用到的CSS屬性、clip-path去繪製多邊形及秒針\n這次在CSS的部分卡了滿長的一段時間，主要是花在使用純CSS刻出秒針以及多邊形花了大部分的時間，其餘的排版、程式邏輯的部分相對來說不算太複雜\n在這邊簡單的跟大家分享一下怎麼透過clip-path去繪製時鐘所需的圖形\nclip-path clip-path會透過裁減的方式在元素內創建可顯示的區塊，顯示區塊外的部分則隱藏，本身有提供circle(圓形)、ellipse(橢圓形)、inset(內置矩形)、polygon(多邊形)等等的方式創建圖形\n要創建秒針跟多邊形會需要使用到polygon，polygon可以設定多個「點」，點跟點之間會有線連接在一起形成多邊形，透過X(水平)、Y(垂直)來設定點的位置，單位可以使用「px」或是「百分比」，秒針針頭的部分另外做之後在外層用一個元素包起來就好\n解說圖就別太計較設計了，真的不太會畫畫\u0026hellip;\n時鐘 codepen連結 clip-path補充 在前面有提到過clip-path會有顯示的區塊及隱藏的區塊，我們可以透過這個遮罩的效果搭配CSS做出遮蓋文字的特效\n我們需要透過inset內置矩形去做，inset可給2個值(上下、左右)或是4個值(上、右、下、左)，設定該方向的值就會由該方向由外往內推，單位同樣可以用px或是百分比\n文字動態 codepen連結 參考資料: https://www.oxxostudio.tw/articles/201503/css-clip-path.html\nhttps://andyyou.github.io/2016/06/28/css-clip-path/\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path\nhttps://css-tricks.com/almanac/properties/c/clip-path/\n","permalink":"https://bjmqfg83.github.io/blog/clock/","tags":["javascript","程式學習"],"title":"時鐘clock-Javascript新手地下城"},{"categories":["javascript"],"contents":"前一陣子同事丟了一個問題要我動動腦練習寫一個迴圈動態，規則如下\n以中心點做為起始點 不斷重複 不論版面是3x3、5x5、7x7、9x9甚至是以上都要能夠正常執行 開發歷程:\n開發的時候在元素上標示上數字可以在開發時幫忙找出中點以及跑迴圈的相關邏輯,建議標上去\n接下來就是找出所需的相關資訊，稍後會在說明要迴圈數、轉折點的主因\n起始點 迴圈數 轉折點 起始點直接除以2取最小整數即可\nvar now_pos = Math.floor(元素總數 / 2); 迴圈數思考一下可以發現3x3是跑一圈迴圈、5x5兩圈、7x7三圈\u0026hellip;\n由此得出以下關係\nvar looptimes = (Math.sqrt(元素總數) - 1) / 2; 轉折點是當中非常重要的關鍵，因為會需要轉折點讓程式判斷跑的方向\n我是取中心點的左右斜對角作為轉折點，並透過迴圈數求出所有轉折點\nfor (var i = 1; i \u0026lt;= looptimes; i++) { // 最後-1是為了對應陣列下標從0開始 // 左上 cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) + 1) - 1); // 右上 cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) - 1) - 1); //右下 cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) + 1) - 1); // 左下 cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) - 1) - 1); } 求出所有的轉折點後可以開始做迴圈的邏輯判斷了\n計算當前所在的點 (最開始是中心點) 與轉折點之間的差值之後求差值得商數及餘數\n餘數作為左右的判斷 商數作為上下的判斷 當前的點大於轉折點迴圈的方向就為左或上 當前的點小於轉折點迴圈的方向就為右或下 重複執行的部分則透過setInterval去做就可以了\n在測試的時候可以改成7x7或9x9看看，一樣可以正常的執行\n之後針對動態如果還有什麼問題都歡迎來找我討論~\n執行結果:\n","permalink":"https://bjmqfg83.github.io/blog/looping_ani/","tags":["javascript","程式學習"],"title":"愛的魔力轉圈圈-不斷重複的迴圈動態"},{"categories":["hugo"],"contents":" 如果想要讓訪客針對你的文章發表評論的話我們可以透過 Disqus 或是 Utterances 快速建立評論留言板\n其實一開始建立個人部落格時評論的套件我使用的是disqus，但是我丟到google的 PageSpeed 測試時發現整個網頁的載入時間有大半以上都花在disqus上面且有很多載入後卻沒有使用到，所以之後便決定改用utterances\n另外上網查了相關的文章說disqus有個資相關的問題，文章結尾會附上相關連結有興趣的可以看一下\nUtterances是什麼? utterances是一個基於github issue的套件，其原理是在github上建立一個公開的repo讓訪客可以針對文章在repo上建立相關的issue，接下來就來跟大家介紹如何在頁面上添加utterances\n在github上建立公開的repository 到utterances安裝頁面後點選install 選擇要安裝utterances的github repo 之後在utterances官網下可以找到區塊進行設置 選擇想要的主題樣式 將產生的script複製下來後放到想要的地方 這樣就完成utterances的設置了\n但要注意utterances是基於github issue所以留言的人需要有github帳號才可以留言\n如果有問題的話歡迎在底下留言\n補充資料 移除disqus留言系統\nThe Problem With Disqus\nWhy I Deleted Disqus and Why You Should Too\n","permalink":"https://bjmqfg83.github.io/blog/hugo_unnerances/","tags":["程式學習"],"title":"如何在hugo上安裝utterances?"},{"categories":["css"],"contents":"當內部元素的寬度超過容器寬度時我們可以使用flex-shrink將內部元素的寬度縮減讓元素不會超過容器\n那flex-shrink到底是怎麼做寬度的縮減?\n基礎公式如下\n元素縮減的寬度 = 超出的總寬度 * 該元素的flex-shrink / 各元素flex-shrink總和\n來看一下code的部分\nJavascript的部分單純只是獲取元素寬度並放在元素上,可以不看\nHTML、CSS原始碼的部分\n1.元素外部容器的寬度為600px\n2.內部元素每個為300px\n3.flex-shrink為1、2、1\n由於內部元素的總寬度超過容器300px,每個設有flex-shrink的元素寬度都會做縮減,用公式算一下每個元素縮減的多少\n元素1\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n150px = 超出的寬度 300px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素寬度為225px、150px、225px,看起來公式沒什麼問題\n如果元素寬度不相同的情況下呢?\n我們先將內部元素寬度設為300px、250px、150px而flex-shrink跟原本一樣為1、2、1\n我們來用公式計算一下\n元素1\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n50px = 超出的寬度 100px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n計算出來的寬度為275px、200px、125px\n那我們現在實際來看一下程式碼\n實際計算出來的寬為269px、197px、134px,跟用公式算出來的不一樣\n其實我們在網路上看到很多講flex-shrink公式是被簡化過的,只有當元素的寬度都一樣才可以這樣用,實際的公式需要將元素寬度考量進去\n首先先將元素的寬度乘以flex-shrink相加來計算總權重\n總權重 950 = 300px * 1 + 250px * 2 + 150px * 1\n修正的公式如下:\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n現在來重新計算縮減的寬度\n元素1\n31.57px = 100px * 1 * 300px / 950\n元素2\n52.63px = 100px * 2 * 250px / 950\n元素3\n15.78px = 100px * 1 * 150px / 950\n計算出來的寬度為268.43px、197.39px、134.22px\n實際來看一下程式碼\n發現計算出來的寬度有小數點的誤差,不過這點可以忽略不計\n補充章節 如果flex-shrink小於1的狀況?\n如果flex-shrink總和小於1則在收縮寬度時不會收縮超出的總寬度,而是會收縮flex-shrink相對於1的比例\n拿上面的例子做修改\n將flex-shrink設為0.1、0.2、0.3\n收縮的總寬度為超出的總寬度100px * 0.6 / 1 = 60px,帶入原先的公式\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n計算新的總權重\n125px = 300px * 0.1 + 250px * 0.2 + 150px * 0.3\n元素1\n14.4px = 60px * 0.1 * 300px / 125\n元素2\n24px = 60px * 0.2 * 250px / 125\n元素3\n21.6px = 60px * 0.3 * 150px / 125\n計算出來的寬度為 285.6px、226px、128.4px\n跟實際的結果會有有零點幾的誤差\n這篇與其說是文章倒不如說是寫筆記會比較正確\n複習flex時剛好有這個疑問就爬文+問人\n希望能幫助一樣有這個疑問的人\n補充資料連結 卡斯柏-圖解：CSS Flex 屬性一點也不難\n詳解flex-grow與flex-shrink\n","permalink":"https://bjmqfg83.github.io/blog/flex-shrink/","tags":["css","程式學習"],"title":"Css flex-shrink是怎麼縮的?"},{"categories":["javascript"],"contents":"最近想複習HTML、CSS、Javascript的基礎概念\n所以開始寫六角學院的新手地下城題目\n使用技術:\nJS : let變數、Template literals樣板字串、for迴圈\nCSS: SCSS(CSS前處理語言)、BEM風格規範(其實這我不確定名稱是否有完全符合BEM的規範)\n開發歷程:\n寫的時候覺得麻煩的地方並不在程式邏輯的地方,反而在思考HTML結構、CSS變數命名的地方佔據的大半的時間,希望日後切板的技術可以越來越純熟\n程式碼:\nhttps://codepen.io/mgnlhdsl/full/NWGObqo\nhttps://bjmqfg83.github.io/multiplication_table/multiplication_table\n","permalink":"https://bjmqfg83.github.io/blog/multiplication_table/","tags":["javascript","程式學習"],"title":"99乘法表-Javascript新手地下城"}]
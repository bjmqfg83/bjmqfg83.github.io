[{"categories":["javascript"],"contents":"使用技術 JS : Vue、axios、For迴圈、Regular expressions、Array\nCSS: SCSS(CSS前處理語言)、flex、customize scrollbar\nOthers: google fonts、政府資料開放平台-空氣品質指標(AQI)\n開發歷程 想要專注在邏輯上所以使用框架開發,當資料更新時由Vue負責畫面渲染\n資料的取得使用axios這個套件串接政府資料開放平台的API，另外頁面的部分做了一個假的selection方便客製化CSS樣式，其餘js程式邏輯使用forEach過濾出符合條件的資料、正規表示法調整更新時間顯示的格式\nXMLHttpRequest 在提交表單資料、串接API這種非同步行為時會希望過程中仍可以對網頁進行操作及瀏覽\n這時候我們可以透過XMLHttpRequest讓網頁在進行非同步的操作時不會卡住或是重整\n//Step 1 創建異步物件  var xhr = new XMLHttpRequest(); //可以簡稱xhr物件 //Step 2 創建異步請求 // method為http請求(get、post...)、url為請求路徑、async為為非同步設定,true為非同步、false為同步 xhr.open(method, url, async); //3.設定監聽事件 // 當xhr物件接受到server的嚮應且響應狀態為200(ok)時進行後續處理 xhr.onreadystatechange = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // 取得響應的訊息  var resText = xhr.responseText; } } // 4.送出請求，send參數除post以外都給null xhr.send(null); 如果是post請求的話需要額外設定RequestHeader，告知server要提交的資料類型並把資料放置send提交\n// 以表單資料為例 xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); var msg = \u0026#39;data1=\u0026#39; + 資料1 +\u0026#39;\u0026amp;\u0026#39;+ \u0026#39;data2\u0026#39; + 資料2... ; xhr.send(msg); 註: 雖然是叫「XML」HttpRequest但也可以使用純文字或是JSON格式的資料\nPromise 在簡單的專案可能還沒關係，但如果專案的需求須要進行多個請求或是要在請求後進行很多程式的處理的話可能會變成下面這樣\n圖片來源: Node 7.6 + Koa 2: asynchronous flow control made right\n這種波動拳的樣子有個別稱叫「Callback hell 回調地獄」，這會造成日後程式維護、擴充上的不便，我們可以透過ES6的Promise來改善,這邊簡單概述一下\nPromise有以下三種狀態\n 擱置(pending)：初始狀態，表示操作進行中 實現(fulfilled) ：表示操作成功，執行resolve(),可透過then查看結果 拒絕(rejected)： 表示操作失敗，執行reject(),可透過catch查看結果  圖片來源: Promise MDN\nfunction PromiseFn() { return new Promise(function (resolve, reject) { var xhr = new XMLHttpRequest(); // 可以把api_key後面的參數改掉刻意引發CORS的錯誤來執行reject  xhr.open(\u0026#34;get\u0026#34;,\u0026#34;https://data.epa.gov.tw/api/v1/aqx_p_432?limit=1000\u0026amp;api_key=9be7b239-557b-4c10-9775-78cadfc555e9\u0026amp;format=json\u0026#34;); // xhr.onreadystatechange可用onload取代  xhr.onload = function() { resolve(JSON.parse(xhr.responseText)); } xhr.onerror = function(){ reject(xhr); } xhr.send(null); }); } PromiseFn() .then(function(res){ ... return PromiseFn(); }).then(function(res2){ ... return PromiseFn(); }).then(function(res3){ ... }).catch(function(error){ ... }); 這樣就避免了波動拳的產生，後續要繼續進行非同步操作時透過return一個Promise的方式進續進行\nPromise還有其他如Promise.all()、Promise.race()等等的方法\u0026hellip;甚至在ES7版本有更好用的Async/Await可以用同步的思維去做非同步的操作，有興趣的朋友可以研究看看\nFetch API 以前如果想要簡化XMLHttpRequest的寫法通常都會使用jQuery的ajax來做，現在在HTML5的標準內我們有原生的Fetch API可以使用\nFetch API有幾點特性\n 使用Promise做回應 使用then做下一步處理、catch作錯誤處理 一開始的回傳為ReadableStream，需要針對不同的資料類型使用對應方法獲取資料ex:json()、text()、blob()\u0026hellip; 只要server有響應不論status code是404或是500Promise的狀態都會是fulfilled而不是rejected，這部分需要額外做處理  現在看一下程式碼\nfetch(\u0026#39;https://jsonplaceholder.typicode.com/todos/1\u0026#39;) .then(res =\u0026gt; { console.log(res); // response的body內可以看到ReadableStream  if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳  }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }) .then(json =\u0026gt; console.log(json)) .catch(err =\u0026gt; { console.error(\u0026#39;錯誤\u0026#39;, err); }); POST方法一樣要設定header跟body\nfetch(url, { method: \u0026#39;POST\u0026#39;, // headers 加入 json 格式  headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, // body 將 json 轉字串送出  body: JSON.stringify({ data_A: \u0026#39;xxxx\u0026#39;, data_B: \u0026#39;xxxx\u0026#39; }).then(res =\u0026gt;{ if(res.ok === true || (res.status \u0026gt;= 200 \u0026amp;\u0026amp; res.status \u0026lt; 300)){ return res.json(); // 將json資料用.json()解析回傳  }else{ throw new Error(\u0026#39;Error happen\u0026#39;); } }).then(jsonData =\u0026gt; {console.log(jsonData)}; ).catch(err =\u0026gt; { console.log(\u0026#39;錯誤:\u0026#39;, err); }) CORS CORS全稱為Cross-Origin Resource Sharing 跨來源資源共享，瀏覽器基於安全性的考量會限制使用者存取其他來源的資源\n以下幾種情況會被當作不同來源\n 不同協定 ex: \u0026quot;https\u0026quot;、\u0026quot;http\u0026quot; 不同domain ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example_others.com\u0026quot; 不同port ex: \u0026quot;https://example.com\u0026quot;、\u0026quot;https://example.com:8080\u0026quot;  跟後端協作串接API時如果遇到CORS通常後端會去設定Access-Control-Allow-Origin來讓特定來源能夠存取資源或是乾脆使用*號(通配符)讓所有不同來源都能夠存取\n但如果要串接的是第三方的API的話可以參考一下六角助教Google Apps Script寫的這篇文章去試看看，大概的理解是CORS是因為瀏覽器請求非同源的資源所發生，那就不用瀏覽器去請求來規避這個問題\n我用新竹縣政府公務人員參訓人數這個API去試了之後沒問題，但是對於像是需要API_KEY金鑰的API如空氣品質指標(AQI)一樣還是會有CORS的問題發生，所以Google Apps Script只是一個暫時性的方式，實作上還是要因應情況去做調整\nAQI Demo連結  參考資料: ReadyState MDN\nPromise MDN\nFetch MDN\nOxxO STUDIO Fetch API 使用教學\n","permalink":"https://bjmqfg83.github.io/blog/air_quality/","tags":["javascript","程式學習"],"title":"全台空氣指標儀表板-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : For迴圈、Date、string、setInterval\nCSS: SCSS(CSS前處理語言)、Grid Layout\nOthers: google fonts\n開發歷程 這次的切版跟程式邏輯都不算複雜,麻煩的是要找Date().toLocaleString的參數設定,有需要的可以看看參考資料的連結，現在這邊來跟各位分享相關知識\n時間戳timestamp timestamp指的是從1970年1月1日0時0分0秒開始到現在總共經過多少豪秒數，可用於追蹤時間、計算時間差、日期排序等等\u0026hellip;，在js內可透過new Date().getTime()取得，不過在查詢資料的時候看到有人說是經過的「秒數」，但使用相關函式獲取到的到底是毫秒還是秒這部分可能跟程式語言、系統環境有關，javascript獲取到的是「毫秒數」、php獲取到的是「秒數」，有興趣的可以到epochconverter、unixtimestamp看看\nGMT、UTC GMT全稱為格林威治標準時間(Greenwich Mean Time)、UTC全稱為世界協調時間(Coordinated Universal Time),台灣所在的時區快八小時所以可以表示成「GMT+8」或是「UTC+8」，那至於GMT、UTC的差別詳細的可以參考泛科學的到底是 GMT+8 還是 UTC+8 ?，日常生活中兩者沒什麼區別可以混用,只是由於地球自轉速度在變慢導致GMT的1秒越來越長，UTC會在超過GMT快1秒時加入「閏秒」來抵消超前的量\nworld clock時區 要獲取指定地區的日期時間我們可使用Date物件的toLocaleString\nnew Date().toLocaleString([locales[, options]]) locales為語言環境，簡單來說是讓時間以該語言的格式顯示，比如說你locales給'zh-tw(台灣)'的話顯示的格式為\u0026quot;2021/2/10 下午1:42:31\u0026quot;，如果給'en-GB(英國)'的話顯示的格式為\u0026quot;10/02/2021, 13:48:17\u0026quot;，但這只是顯示的格式而已,時區還是在使用者所在的地區,如果要顯示別的時區的時間需要透過options做設定\noptions可以設定時區以及年、月、日等等的顯示格式，這邊列出有使用到的\n timeZone =\u0026gt; 設定要顯示的地區時間 hour12 =\u0026gt; 設定顯示是否為12小時制 year =\u0026gt; 設定顯示年分格式 month =\u0026gt; 設定顯示月份格式,可為英文或數字 day =\u0026gt; 設定顯示日期格式 hour =\u0026gt; 設定顯示小時格式 minute =\u0026gt; 設定顯示分鐘格式 注: locales、options內詳細的參數設定可以直接看最後面的參考資料\nJS程式邏輯 // 時區依序為美國、英國倫敦、曼谷、台北、澳洲雪梨  const timeZones = [ \u0026#34;America/New_York\u0026#34;, \u0026#34;Europe/London\u0026#34;, \u0026#34;Asia/Bangkok\u0026#34;, \u0026#34;Asia/Taipei\u0026#34;, \u0026#34;Australia/Sydney\u0026#34; ]; // toLocaleString options參數  const options = { timeZone: \u0026#34;Asia/Taipei\u0026#34;, // 時區設定台北  hour12: false, //不以12小時制顯示,會以24小時制顯示  year: \u0026#34;numeric\u0026#34;, //正常數字顯示  month: \u0026#34;short\u0026#34;, //short只會顯示三位英文 ex: February =\u0026gt; Feb  day: \u0026#34;2-digit\u0026#34;, //顯示兩位 ex: 1 =\u0026gt; 01  hour: \u0026#34;2-digit\u0026#34;, //顯示兩位  minute: \u0026#34;2-digit\u0026#34; //顯示兩位  }; function world_clock() { timeZones.forEach((item, index) =\u0026gt; { var temp_clockInfo = \u0026#34;\u0026#34;; var temp_dateInfo = \u0026#34;\u0026#34;; options.timeZone = item; // 時區使用英國(en-GB)顯示結果就會是日、月、年、時間  temp_clockInfo = new Date().toLocaleString(\u0026#34;en-GB\u0026#34;, options); //月份後面添加「. 」後重新拼接日期字串  temp_dateInfo = temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[0] + \u0026#34; \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[1] + \u0026#34;. \u0026#34; + temp_clockInfo.split(\u0026#34;,\u0026#34;)[0].split(\u0026#34; \u0026#34;)[2]; //更新年月日的元素  document.querySelectorAll(\u0026#34;.location-info .location-date\u0026#34;)[index].innerText = temp_dateInfo; //依格式中的「,」分割出時分後更新DOM,透過index下標去找目標元素  document.querySelectorAll(\u0026#34;.location-info \u0026gt; div:nth-of-type(2)\u0026#34;)[index].innerText = temp_clockInfo.split(\u0026#34;,\u0026#34;)[1].trim(); }); } world_clock(); // 每秒鐘調用一次判斷getSeconds()是否為59，為59示1分鐘要到可以調用函數更新時間  var clock_timer = setInterval(function(){ if(new Date().getSeconds()===59){ world_clock(); } },1000); world clock codepen連結  參考資料: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/DateTimeFormat\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\nhttps://blog.techbridge.cc/2020/12/26/javascript-date-time-and-timezone/\n","permalink":"https://bjmqfg83.github.io/blog/world_clock/","tags":["javascript","程式學習"],"title":"WORLD CLOCK-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術 JS : Vue、正規表達式、String(substring、replace、split)、For迴圈、Array(reverse)\nCSS: SCSS(CSS前處理語言)、Customize Scrollbar\n開發歷程 這次寫題目時想順便複習FrameWork所以使用了Vue做開發，花了滿多時間想怎麼在千分位前加上「,」以及避免計算結果出現「undefined」、「NAN」\n千分位資料處理 整數位數超過三位時要加上千分位符「,」需要使用正規表達式、字串、陣列的方法來處理\n//當計算機輸入到加、減、乘、除時對運算符前的數字做千分位符的處理 // +號在正規表達式有特定意思所以要單純匹配需在前面加上「反斜線」 // g表示要找出所有符合條件的結果，不加的話只會找出第一筆符合條件的結果就結束 const comma_rule = /(\\+|-|×|÷)/g; let prev_comma = \u0026#34;\u0026#34;; //整數位 let after_comma = \u0026#34;\u0026#34;; //小數位 let comma_val = \u0026#34;\u0026#34;; //加上千分位的結果 function compute_comma(){ comma_arr = result.split(comma_rule); //依據規則分隔出符合條件的陣列資料  comma_arr.forEach((item, index) =\u0026gt; { if (!isNaN(parseFloat(item))) { // 判斷是否為加、減、乘、除,只處理非NAN的資料  prev_comma = (item.split(\u0026#34;.\u0026#34;)[0] || \u0026#34;\u0026#34;).split(\u0026#34;\u0026#34;).reverse(); //整數位轉成陣列處理  after_comma = item.split(\u0026#34;.\u0026#34;)[1] || \u0026#34;\u0026#34;; //小數點先暫存進變數等處理完整數之後再整合進去  comma_val = \u0026#34;\u0026#34;; //每次迴圈前先清空  //前面的reverse()用來方便拼接字串  //ex:[3,8,5,6].reverse() =\u0026gt; [6,5,8,3]  for (let i = 0; i \u0026lt; prev_comma.length; i++) { //當到第四位時在第三位前加上千分位符「,」  if (i % 3 === 0 \u0026amp;\u0026amp; i !== 0) { // step 4 =\u0026gt; \u0026#34;3\u0026#34;+\u0026#34;,\u0026#34;+\u0026#34;856\u0026#34;  comma_val = prev_comma[i] + \u0026#34;,\u0026#34; + comma_val; //非第四位則單純拼接  } else { // step 1 =\u0026gt; \u0026#34;6\u0026#34;+ \u0026#34;\u0026#34;、step 2 =\u0026gt; \u0026#34;5\u0026#34; + \u0026#34;6\u0026#34;、step 3 =\u0026gt; \u0026#34;8\u0026#34; + \u0026#34;56\u0026#34;  comma_val = prev_comma[i] + comma_val; } } } }); } 其餘的輸入規則如避免「NAN」、「undefined」讀者可以稍微思考一下如何處理，這邊就不贅述\nScrollbar客製化 稍微看過其他人做的計算機在位數過多時滿多都是使用js調整字體大小來避免畫面破格,但我個人不太想要調整字體大小所以選擇用css處理位數過多的問題，在畫面位數過多時會出現scrollbar可以滑動，可能會有人覺得瀏覽器預設的不是很好看，這部分可以透過css去調整\n注:scrollbar的調整Firefox要額外寫\nFirefox scrollbar-width: auto | thin | none | 1em | inherit | initial | unset ; scrollbar-color: auto | dark | light | color1(滾動條本身的顏色thumb) color2(滾動條外容器的顏色track); 注: color1、color2可以用關鍵字(red、blue\u0026hellip;)或是色碼\nChrome、IE Edge、Safari /* 屬性前要加::-webkit-前綴字 */ ::-webkit-scrollbar: width | height ; ::-webkit-scrollbar-thumb: background | box-shadow | ... ; 注: 這邊簡單列出有使用到的，有需要的話可參考底下連結\n計算機 codepen連結  參考資料: https://css-tricks.com/custom-scrollbars-in-webkit/\nhttps://css-tricks.com/examples/WebKitScrollbars/\nhttps://stackoverflow.com/questions/6165472/custom-css-scrollbar-for-firefox/53739309#53739309\nhttps://github.com/Aris-t2/CustomCSSforFx/issues/160\n","permalink":"https://bjmqfg83.github.io/blog/hex_calculator/","tags":["javascript","程式學習"],"title":"計算機Calculator-Javascript新手地下城"},{"categories":["javascript"],"contents":"使用技術: JS : Const變數、Date物件、SetInterval、Template literals樣板字串\nCSS: SCSS(CSS前處理語言)、clip-path\n開發歷程: JS的部分透過Date物件獲取當前的時間、setInterval更新時間並且在內部判斷指針的轉動、Template literals用於方便將計算指出來的旋轉角度整合進字串內\nCSS的部分使用SCSS變數去存取顏色、mixin存取會大量使用到的CSS屬性、clip-path去繪製多邊形及秒針\n這次在CSS的部分卡了滿長的一段時間，主要是花在使用純CSS刻出秒針以及多邊形花了大部分的時間，其餘的排版、程式邏輯的部分相對來說不算太複雜\n在這邊簡單的跟大家分享一下怎麼透過clip-path去繪製時鐘所需的圖形\nclip-path clip-path會透過裁減的方式在元素內創建可顯示的區塊，顯示區塊外的部分則隱藏，本身有提供circle(圓形)、ellipse(橢圓形)、inset(內置矩形)、polygon(多邊形)等等的方式創建圖形\n要創建秒針跟多邊形會需要使用到polygon，polygon可以設定多個「點」，點跟點之間會有線連接在一起形成多邊形，透過X(水平)、Y(垂直)來設定點的位置，單位可以使用「px」或是「百分比」，秒針針頭的部分另外做之後在外層用一個元素包起來就好\n解說圖就別太計較設計了，真的不太會畫畫\u0026hellip;\n時鐘 codepen連結  clip-path補充 在前面有提到過clip-path會有顯示的區塊及隱藏的區塊，我們可以透過這個遮罩的效果搭配CSS做出遮蓋文字的特效\n我們需要透過inset內置矩形去做，inset可給2個值(上下、左右)或是4個值(上、右、下、左)，設定該方向的值就會由該方向由外往內推，單位同樣可以用px或是百分比\n文字動態 codepen連結  參考資料: https://www.oxxostudio.tw/articles/201503/css-clip-path.html\nhttps://andyyou.github.io/2016/06/28/css-clip-path/\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/clip-path\nhttps://css-tricks.com/almanac/properties/c/clip-path/\n","permalink":"https://bjmqfg83.github.io/blog/clock/","tags":["javascript","程式學習"],"title":"時鐘clock-Javascript新手地下城"},{"categories":["javascript"],"contents":"前一陣子同事丟了一個問題要我動動腦練習寫一個迴圈動態，規則如下\n 以中心點做為起始點 不斷重複 不論版面是3x3、5x5、7x7、9x9甚至是以上都要能夠正常執行  開發歷程:\n開發的時候在元素上標示上數字可以在開發時幫忙找出中點以及跑迴圈的相關邏輯,建議標上去\n接下來就是找出所需的相關資訊，稍後會在說明要迴圈數、轉折點的主因\n 起始點 迴圈數 轉折點  起始點直接除以2取最小整數即可\nvar now_pos = Math.floor(元素總數 / 2); 迴圈數思考一下可以發現3x3是跑一圈迴圈、5x5兩圈、7x7三圈\u0026hellip;\n由此得出以下關係\nvar looptimes = (Math.sqrt(元素總數) - 1) / 2; 轉折點是當中非常重要的關鍵，因為會需要轉折點讓程式判斷跑的方向\n我是取中心點的左右斜對角作為轉折點，並透過迴圈數求出所有轉折點\nfor (var i = 1; i \u0026lt;= looptimes; i++) { // 最後-1是為了對應陣列下標從0開始  // 左上  cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) + 1) - 1); // 右上  cp.push(Math.ceil(元素總數 / 2) - i * (Math.sqrt(元素總數) - 1) - 1); //右下  cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) + 1) - 1); // 左下  cp.push(Math.ceil(元素總數 / 2) + i * (Math.sqrt(元素總數) - 1) - 1); } 求出所有的轉折點後可以開始做迴圈的邏輯判斷了\n計算當前所在的點 (最開始是中心點) 與轉折點之間的差值之後求差值得商數及餘數\n 餘數作為左右的判斷 商數作為上下的判斷 當前的點大於轉折點迴圈的方向就為左或上 當前的點小於轉折點迴圈的方向就為右或下  重複執行的部分則透過setInterval去做就可以了\n在測試的時候可以改成7x7或9x9看看，一樣可以正常的執行\n之後針對動態如果還有什麼問題都歡迎來找我討論~\n執行結果:\n ","permalink":"https://bjmqfg83.github.io/blog/looping_ani/","tags":["javascript","程式學習"],"title":"愛的魔力轉圈圈-不斷重複的迴圈動態"},{"categories":["hugo"],"contents":"如果想要讓訪客針對你的文章發表評論的話我們可以透過 Disqus 或是 Utterances 快速建立評論留言板\n其實一開始建立個人部落格時評論的套件我使用的是disqus，但是我丟到google的 PageSpeed 測試時發現整個網頁的載入時間有大半以上都花在disqus上面且有很多載入後卻沒有使用到，所以之後便決定改用utterances\n另外上網查了相關的文章說disqus有個資相關的問題，文章結尾會附上相關連結有興趣的可以看一下\nUtterances是什麼? utterances是一個基於github issue的套件，其原理是在github上建立一個公開的repo讓訪客可以針對文章在repo上建立相關的issue，接下來就來跟大家介紹如何在頁面上添加utterances\n 在github上建立公開的repository  到utterances安裝頁面後點選install  選擇要安裝utterances的github repo  之後在utterances官網下可以找到區塊進行設置  選擇想要的主題樣式  將產生的script複製下來後放到想要的地方  這樣就完成utterances的設置了\n但要注意utterances是基於github issue所以留言的人需要有github帳號才可以留言\n如果有問題的話歡迎在底下留言\n補充資料 移除disqus留言系統\nThe Problem With Disqus\nWhy I Deleted Disqus and Why You Should Too\n","permalink":"https://bjmqfg83.github.io/blog/hugo_unnerances/","tags":["程式學習"],"title":"如何在hugo上安裝utterances?"},{"categories":["css"],"contents":"當內部元素的寬度超過容器寬度時我們可以使用flex-shrink將內部元素的寬度縮減讓元素不會超過容器\n那flex-shrink到底是怎麼做寬度的縮減?\n基礎公式如下\n元素縮減的寬度 = 超出的總寬度 * 該元素的flex-shrink / 各元素flex-shrink總和\n來看一下code的部分\n Javascript的部分單純只是獲取元素寬度並放在元素上,可以不看\nHTML、CSS原始碼的部分\n1.元素外部容器的寬度為600px\n2.內部元素每個為300px\n3.flex-shrink為1、2、1\n由於內部元素的總寬度超過容器300px,每個設有flex-shrink的元素寬度都會做縮減,用公式算一下每個元素縮減的多少\n元素1\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n150px = 超出的寬度 300px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n75px = 超出的寬度 300px * 各別flex-shrink 1 / flex-shrink總和 4\n元素寬度為225px、150px、225px,看起來公式沒什麼問題\n如果元素寬度不相同的情況下呢?\n我們先將內部元素寬度設為300px、250px、150px而flex-shrink跟原本一樣為1、2、1\n我們來用公式計算一下\n元素1\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n元素2\n50px = 超出的寬度 100px * 各別flex-shrink 2/ flex-shrink總和 4\n元素3\n25px = 超出的寬度 100px * 各別flex-shrink 1 / flex-shrink總和 4\n計算出來的寬度為275px、200px、125px\n那我們現在實際來看一下程式碼\n 實際計算出來的寬為269px、197px、134px,跟用公式算出來的不一樣\n其實我們在網路上看到很多講flex-shrink公式是被簡化過的,只有當元素的寬度都一樣才可以這樣用,實際的公式需要將元素寬度考量進去\n首先先將元素的寬度乘以flex-shrink相加來計算總權重\n總權重 950 = 300px * 1 + 250px * 2 + 150px * 1\n修正的公式如下:\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n現在來重新計算縮減的寬度\n元素1\n31.57px = 100px * 1 * 300px / 950\n元素2\n52.63px = 100px * 2 * 250px / 950\n元素3\n15.78px = 100px * 1 * 150px / 950\n計算出來的寬度為268.43px、197.39px、134.22px\n實際來看一下程式碼\n 發現計算出來的寬度有小數點的誤差,不過這點可以忽略不計\n補充章節 如果flex-shrink小於1的狀況?\n如果flex-shrink總和小於1則在收縮寬度時不會收縮超出的總寬度,而是會收縮flex-shrink相對於1的比例\n拿上面的例子做修改\n將flex-shrink設為0.1、0.2、0.3\n收縮的總寬度為超出的總寬度100px * 0.6 / 1 = 60px,帶入原先的公式\n元素縮減的寬度 = 超出的總寬度 * 各別flex-shrink * 各別元素的寬度 / 總權重\n計算新的總權重\n125px = 300px * 0.1 + 250px * 0.2 + 150px * 0.3\n元素1\n14.4px = 60px * 0.1 * 300px / 125\n元素2\n24px = 60px * 0.2 * 250px / 125\n元素3\n21.6px = 60px * 0.3 * 150px / 125\n計算出來的寬度為 285.6px、226px、128.4px\n跟實際的結果會有有零點幾的誤差\n 這篇與其說是文章倒不如說是寫筆記會比較正確\n複習flex時剛好有這個疑問就爬文+問人\n希望能幫助一樣有這個疑問的人\n補充資料連結 卡斯柏-圖解：CSS Flex 屬性一點也不難\n詳解flex-grow與flex-shrink\n","permalink":"https://bjmqfg83.github.io/blog/flex-shrink/","tags":["css","程式學習"],"title":"Css flex-shrink是怎麼縮的?"},{"categories":["javascript"],"contents":"最近想複習HTML、CSS、Javascript的基礎概念\n所以開始寫六角學院的新手地下城題目\n使用技術:\nJS : let變數、Template literals樣板字串、for迴圈\nCSS: SCSS(CSS前處理語言)、BEM風格規範(其實這我不確定名稱是否有完全符合BEM的規範)\n開發歷程:\n寫的時候覺得麻煩的地方並不在程式邏輯的地方,反而在思考HTML結構、CSS變數命名的地方佔據的大半的時間,希望日後切板的技術可以越來越純熟\n 程式碼:\nhttps://codepen.io/mgnlhdsl/full/NWGObqo\nhttps://bjmqfg83.github.io/multiplication_table/multiplication_table\n","permalink":"https://bjmqfg83.github.io/blog/multiplication_table/","tags":["javascript","程式學習"],"title":"99乘法表-Javascript新手地下城"}]